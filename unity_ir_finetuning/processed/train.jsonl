{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Grenade\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"explosionRadius\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"explosionDamage\",\n      \"type\": \"float\",\n      \"default\": 50.0\n    },\n    {\n      \"name\": \"fuseDelay\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_fuse_countdown\",\n      \"trigger\": \"when grenade is thrown\",\n      \"actions\": [\n        {\n          \"action\": \"start timer for explosion\"\n        },\n        {\n          \"action\": \"begin blinking visual warning\"\n        }\n      ]\n    },\n    {\n      \"name\": \"detonate\",\n      \"trigger\": \"after fuse delay expires\",\n      \"actions\": [\n        {\n          \"action\": \"create explosive blast effect\"\n        },\n        {\n          \"action\": \"damage nearby objects and characters\"\n        },\n        {\n          \"action\": \"apply radial force to surrounding physics objects\"\n        },\n        {\n          \"action\": \"destroy grenade object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"early_detonation\",\n      \"trigger\": \"when grenade collides with explosive surface\",\n      \"actions\": [\n        {\n          \"action\": \"immediately trigger explosion\"\n        },\n        {\n          \"action\": \"ignore remaining fuse time\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class Grenade : MonoBehaviour\n{\n    [SerializeField] private float explosionDelay = 3f;\n    [SerializeField] private float explosionRadius = 5f;\n    [SerializeField] private int damageAmount = 50;\n    [SerializeField] private GameObject explosionEffectPrefab;\n\n    [SerializeField] private LayerMask targetLayers;\n\n    private float currentTimer;\n    private bool hasExploded = false;\n\n    private void Start()\n    {\n        currentTimer = explosionDelay;\n    }\n\n    private void Update()\n    {\n        if (hasExploded) return;\n\n        currentTimer -= Time.deltaTime;\n\n        if (currentTimer <= 0f)\n        {\n            Explode();\n        }\n    }\n\n    private void Explode()\n    {\n        hasExploded = true;\n\n        // Detect nearby colliders\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, explosionRadius, targetLayers);\n\n        foreach (Collider hitCollider in hitColliders)\n        {\n            // Apply damage to damageable objects\n            IDamageable damageable = hitCollider.GetComponent<IDamageable>();\n            damageable?.TakeDamage(damageAmount);\n        }\n\n        // Spawn explosion effect\n        if (explosionEffectPrefab != null)\n        {\n            Instantiate(explosionEffectPrefab, transform.position, Quaternion.identity);\n        }\n\n        // Destroy grenade object\n        Destroy(gameObject);\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        // Visualize explosion radius in scene view\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, explosionRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SwordController\",\n  \"components\": [\n    \"Animator\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"swingForce\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"swingCooldown\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"isReadyToSwing\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"attack_swing\",\n      \"trigger\": \"player presses attack button\",\n      \"actions\": [\n        {\n          \"action\": \"play sword swing animation\"\n        },\n        {\n          \"action\": \"play sword swing sound effect\"\n        },\n        {\n          \"action\": \"apply swing force in attack direction\"\n        },\n        {\n          \"action\": \"start swing cooldown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"swing_cooldown\",\n      \"trigger\": \"after sword swing occurs\",\n      \"actions\": [\n        {\n          \"action\": \"prevent additional swings temporarily\"\n        },\n        {\n          \"action\": \"reset swing readiness after cooldown period\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SwordSwing : MonoBehaviour\n{\n    [SerializeField] private Animator swordAnimator;\n    [SerializeField] private float swingCooldown = 0.5f;\n    [SerializeField] private AudioClip swingSound;\n\n    private AudioSource audioSource;\n    private float lastSwingTime;\n    private bool canSwing = true;\n\n    private void Start()\n    {\n        // Ensure animator is assigned\n        if (swordAnimator == null)\n            swordAnimator = GetComponent<Animator>();\n\n        // Setup audio source for swing sound\n        audioSource = GetComponent<AudioSource>();\n        if (audioSource == null)\n            audioSource = gameObject.AddComponent<AudioSource>();\n    }\n\n    private void Update()\n    {\n        // Check for swing input\n        if (Input.GetButtonDown(\"Fire1\") && canSwing)\n        {\n            PerformSwordSwing();\n        }\n\n        // Manage swing cooldown\n        if (!canSwing)\n        {\n            if (Time.time >= lastSwingTime + swingCooldown)\n            {\n                canSwing = true;\n            }\n        }\n    }\n\n    private void PerformSwordSwing()\n    {\n        // Trigger swing animation\n        if (swordAnimator != null)\n        {\n            swordAnimator.SetTrigger(\"Swing\");\n        }\n\n        // Play swing sound\n        if (swingSound != null && audioSource != null)\n        {\n            audioSource.PlayOneShot(swingSound);\n        }\n\n        // Set cooldown\n        lastSwingTime = Time.time;\n        canSwing = false;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AmbientSoundZone\",\n  \"components\": [\n    \"AudioSource\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"soundClip\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"volumeLevel\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"zoneRadius\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"fadeInTime\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"fadeOutTime\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"enter_sound_zone\",\n      \"trigger\": \"when player enters trigger area\",\n      \"actions\": [\n        {\n          \"action\": \"start playing ambient sound\"\n        },\n        {\n          \"action\": \"gradually increase sound volume\"\n        },\n        {\n          \"action\": \"adjust sound based on player's proximity\"\n        }\n      ]\n    },\n    {\n      \"name\": \"exit_sound_zone\",\n      \"trigger\": \"when player leaves trigger area\",\n      \"actions\": [\n        {\n          \"action\": \"gradually decrease sound volume\"\n        },\n        {\n          \"action\": \"stop playing ambient sound after fade out\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class AmbientSoundZone : MonoBehaviour\n{\n    [SerializeField] private AudioClip ambientClip;\n    [SerializeField] private float volumeLevel = 0.5f;\n    [SerializeField] private float transitionSpeed = 2f;\n    [SerializeField] private float triggerRadius = 5f;\n\n    private AudioSource audioSource;\n    private bool playerInZone = false;\n\n    private void Start()\n    {\n        // Initialize audio source component\n        audioSource = gameObject.AddComponent<AudioSource>();\n        audioSource.clip = ambientClip;\n        audioSource.loop = true;\n        audioSource.volume = 0f;\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        // Check if player entered the zone\n        if (other.CompareTag(\"Player\"))\n        {\n            playerInZone = true;\n        }\n    }\n\n    private void OnTriggerExit(Collider other)\n    {\n        // Check if player left the zone\n        if (other.CompareTag(\"Player\"))\n        {\n            playerInZone = false;\n        }\n    }\n\n    private void Update()\n    {\n        // Smoothly fade audio in and out\n        float targetVolume = playerInZone ? volumeLevel : 0f;\n        audioSource.volume = Mathf.Lerp(audioSource.volume, targetVolume, Time.deltaTime * transitionSpeed);\n\n        // Play or pause audio based on zone status\n        if (playerInZone && !audioSource.isPlaying)\n        {\n            audioSource.Play();\n        }\n        else if (!playerInZone && audioSource.volume <= 0.01f)\n        {\n            audioSource.Pause();\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        // Visualize trigger radius in scene view\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, triggerRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SpeedBoostPickup\",\n  \"components\": [\n    \"Collider\",\n    \"SpriteRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"boostAmount\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"boostDuration\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"activate_speed_boost\",\n      \"trigger\": \"when player collides with pickup\",\n      \"actions\": [\n        {\n          \"action\": \"increase player movement speed\"\n        },\n        {\n          \"action\": \"make pickup disappear\"\n        },\n        {\n          \"action\": \"start countdown timer for boost duration\"\n        },\n        {\n          \"action\": \"play pickup sound effect\"\n        },\n        {\n          \"action\": \"reset player speed after duration expires\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SpeedBoostPickup : MonoBehaviour\n{\n    [SerializeField] private float boostMultiplier = 1.5f;\n    [SerializeField] private float boostDuration = 5f;\n    [SerializeField] private AudioClip pickupSound;\n\n    private void OnTriggerEnter(Collider other)\n    {\n        PlayerMovement playerMovement = other.GetComponent<PlayerMovement>();\n        \n        if (playerMovement != null)\n        {\n            ApplySpeedBoost(playerMovement);\n        }\n    }\n\n    private void ApplySpeedBoost(PlayerMovement playerMovement)\n    {\n        // Play pickup sound if assigned\n        if (pickupSound != null)\n        {\n            AudioSource.PlayClipAtPoint(pickupSound, transform.position);\n        }\n\n        // Apply speed boost to player\n        playerMovement.ApplyTemporarySpeedBoost(boostMultiplier, boostDuration);\n\n        // Destroy pickup object\n        Destroy(gameObject);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DamageNumberDisplay\",\n  \"components\": [\n    \"Text\",\n    \"Animation\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"damageTextPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"floatSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"fadeOutTime\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"spawn_damage_number\",\n      \"trigger\": \"when damage is received by game object\",\n      \"actions\": [\n        {\n          \"action\": \"instantiate damage text at damage location\"\n        },\n        {\n          \"action\": \"set text to amount of damage taken\"\n        },\n        {\n          \"action\": \"animate text to float upward\"\n        },\n        {\n          \"action\": \"fade out text over short duration\"\n        },\n        {\n          \"action\": \"destroy text object after animation completes\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing TMPro;\n\npublic class DamageNumberController : MonoBehaviour\n{\n    [SerializeField] private TextMeshProUGUI damageTextPrefab;\n    [SerializeField] private float floatSpeed = 1f;\n    [SerializeField] private float fadeOutTime = 1f;\n\n    public void SpawnDamageNumber(int damageAmount, Vector3 spawnPosition)\n    {\n        if (damageTextPrefab == null)\n        {\n            Debug.LogWarning(\"Damage text prefab is not assigned!\");\n            return;\n        }\n\n        TextMeshProUGUI damageText = Instantiate(damageTextPrefab, spawnPosition, Quaternion.identity);\n        damageText.text = damageAmount.ToString();\n\n        StartCoroutine(AnimateDamageNumber(damageText));\n    }\n\n    private System.Collections.IEnumerator AnimateDamageNumber(TextMeshProUGUI damageText)\n    {\n        float elapsedTime = 0f;\n\n        while (elapsedTime < fadeOutTime)\n        {\n            damageText.transform.position += Vector3.up * floatSpeed * Time.deltaTime;\n            \n            // Fade out effect\n            damageText.color = new Color(\n                damageText.color.r, \n                damageText.color.g, \n                damageText.color.b, \n                Mathf.Lerp(1f, 0f, elapsedTime / fadeOutTime)\n            );\n\n            elapsedTime += Time.deltaTime;\n            yield return null;\n        }\n\n        Destroy(damageText.gameObject);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LandMine\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"explosionRadius\",\n      \"type\": \"float\",\n      \"default\": 3.5\n    },\n    {\n      \"name\": \"damageAmount\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"isArmed\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detonate\",\n      \"trigger\": \"when any object touches the mine's surface\",\n      \"actions\": [\n        {\n          \"action\": \"play explosion sound\"\n        },\n        {\n          \"action\": \"create explosion particle effect\"\n        },\n        {\n          \"action\": \"damage nearby objects within explosion radius\"\n        },\n        {\n          \"action\": \"destroy mine object\"\n        },\n        {\n          \"action\": \"disable mine's ability to trigger again\"\n        }\n      ]\n    },\n    {\n      \"name\": \"disarm\",\n      \"trigger\": \"when specific condition is met\",\n      \"actions\": [\n        {\n          \"action\": \"set mine as unarmed\"\n        },\n        {\n          \"action\": \"stop mine from being able to detonate\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class LandMine : MonoBehaviour\n{\n    [SerializeField] private float explosionRadius = 3f;\n    [SerializeField] private float explosionDamage = 50f;\n    [SerializeField] private GameObject explosionEffectPrefab;\n    [SerializeField] private AudioClip explosionSound;\n\n    [SerializeField] private LayerMask triggerLayers;\n\n    private bool hasDetonated = false;\n\n    private void OnTriggerEnter(Collider other)\n    {\n        // Check if mine hasn't already detonated and is on a valid trigger layer\n        if (!hasDetonated && ((1 << other.gameObject.layer & triggerLayers) != 0))\n        {\n            Detonate();\n        }\n    }\n\n    private void Detonate()\n    {\n        // Mark mine as detonated to prevent multiple explosions\n        hasDetonated = true;\n\n        // Play explosion effect\n        if (explosionEffectPrefab != null)\n        {\n            Instantiate(explosionEffectPrefab, transform.position, Quaternion.identity);\n        }\n\n        // Play explosion sound\n        if (explosionSound != null)\n        {\n            AudioSource.PlayClipAtPoint(explosionSound, transform.position);\n        }\n\n        // Damage nearby colliders\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, explosionRadius);\n        foreach (Collider hitCollider in hitColliders)\n        {\n            // Check if hit object has a health component\n            IDamageable damageable = hitCollider.GetComponent<IDamageable>();\n            if (damageable != null)\n            {\n                // Calculate distance-based damage falloff\n                float distance = Vector3.Distance(transform.position, hitCollider.transform.position);\n                float damageMultiplier = 1f - (distance / explosionRadius);\n                damageable.TakeDamage(explosionDamage * damageMultiplier);\n            }\n        }\n\n        // Destroy the mine\n        Destroy(gameObject);\n    }\n\n    // Optional debug visualization in scene view\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, explosionRadius);\n    }\n}\n\n// Optional interface for damage handling\npublic interface IDamageable\n{\n    void TakeDamage(float damage);\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HealthPickup\",\n  \"components\": [\n    \"Collider\",\n    \"SpriteRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"healAmount\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"player_healing\",\n      \"trigger\": \"when player collides with health pickup\",\n      \"actions\": [\n        {\n          \"action\": \"increase player's health by heal amount\"\n        },\n        {\n          \"action\": \"play healing sound effect\"\n        },\n        {\n          \"action\": \"make health pickup disappear\"\n        },\n        {\n          \"action\": \"disable health pickup\"\n        }\n      ]\n    },\n    {\n      \"name\": \"respawn_behavior\",\n      \"trigger\": \"after certain time since pickup\",\n      \"actions\": [\n        {\n          \"action\": \"reset health pickup to original position\"\n        },\n        {\n          \"action\": \"make health pickup visible again\"\n        },\n        {\n          \"action\": \"reactivate health pickup\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class HealthPickup : MonoBehaviour\n{\n    [SerializeField] private int healAmount = 25;\n    [SerializeField] private AudioClip pickupSound;\n    [SerializeField] private GameObject pickupEffectPrefab;\n\n    private void OnTriggerEnter(Collider other)\n    {\n        // Check if the colliding object is the player\n        PlayerHealth playerHealth = other.GetComponent<PlayerHealth>();\n        \n        if (playerHealth != null)\n        {\n            // Heal the player\n            playerHealth.Heal(healAmount);\n\n            // Play pickup sound if assigned\n            if (pickupSound != null)\n            {\n                AudioSource.PlayClipAtPoint(pickupSound, transform.position);\n            }\n\n            // Spawn pickup effect if assigned\n            if (pickupEffectPrefab != null)\n            {\n                Instantiate(pickupEffectPrefab, transform.position, Quaternion.identity);\n            }\n\n            // Destroy the pickup\n            Destroy(gameObject);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CrosshairController\",\n  \"components\": [\n    \"UI Image\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"defaultCrosshairSprite\",\n      \"type\": \"sprite\",\n      \"default\": null\n    },\n    {\n      \"name\": \"hoverCrosshairSprite\",\n      \"type\": \"sprite\",\n      \"default\": null\n    },\n    {\n      \"name\": \"currentTarget\",\n      \"type\": \"gameobject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_hover_target\",\n      \"trigger\": \"mouse cursor moves over interactive object\",\n      \"actions\": [\n        {\n          \"action\": \"update current target to object under mouse\"\n        },\n        {\n          \"action\": \"change crosshair sprite to hover version\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_crosshair\",\n      \"trigger\": \"mouse cursor leaves interactive object\",\n      \"actions\": [\n        {\n          \"action\": \"clear current target\"\n        },\n        {\n          \"action\": \"restore default crosshair sprite\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class CrosshairController : MonoBehaviour\n{\n    [SerializeField] private Sprite defaultCrosshair;\n    [SerializeField] private Sprite hoverCrosshair;\n    [SerializeField] private Image crosshairImage;\n\n    [SerializeField] private float raycastDistance = 100f;\n    [SerializeField] private LayerMask interactableLayer;\n\n    private void Update()\n    {\n        // Perform raycast from center of screen\n        Ray ray = Camera.main.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0));\n        RaycastHit hit;\n\n        // Check if raycast hits an interactable object\n        if (Physics.Raycast(ray, out hit, raycastDistance, interactableLayer))\n        {\n            // Object is being looked at, change crosshair\n            if (crosshairImage != null && hoverCrosshair != null)\n            {\n                crosshairImage.sprite = hoverCrosshair;\n            }\n        }\n        else\n        {\n            // Reset to default crosshair\n            if (crosshairImage != null && defaultCrosshair != null)\n            {\n                crosshairImage.sprite = defaultCrosshair;\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ExplodingEnemy\",\n  \"components\": [\n    \"Health\",\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"explosionRadius\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"explosionDamage\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"health\",\n      \"type\": \"float\",\n      \"default\": 100\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when enemy receives damage that reduces health to zero or below\",\n      \"actions\": [\n        {\n          \"action\": \"create explosion effect at current location\"\n        },\n        {\n          \"action\": \"damage nearby objects within explosion radius\"\n        },\n        {\n          \"action\": \"destroy enemy game object\"\n        }\n      ]\n    },\n    {\n      \"name\": \"damage_nearby_objects\",\n      \"trigger\": \"during explosion\",\n      \"actions\": [\n        {\n          \"action\": \"detect all objects within explosion radius\"\n        },\n        {\n          \"action\": \"apply damage proportional to distance from explosion center\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class EnemyExplosion : MonoBehaviour\n{\n    [SerializeField] private float explosionRadius = 3f;\n    [SerializeField] private int explosionDamage = 50;\n    [SerializeField] private GameObject explosionEffectPrefab;\n    [SerializeField] private LayerMask damageLayers;\n\n    private bool hasExploded = false;\n\n    public void TakeDamage(int damage)\n    {\n        // Check if enemy is already dead/exploded\n        if (hasExploded) return;\n\n        // Trigger explosion when health reaches zero\n        if (damage >= GetComponent<Health>().CurrentHealth)\n        {\n            Explode();\n        }\n    }\n\n    private void Explode()\n    {\n        // Prevent multiple explosions\n        if (hasExploded) return;\n        hasExploded = true;\n\n        // Spawn explosion visual effect\n        if (explosionEffectPrefab != null)\n        {\n            Instantiate(explosionEffectPrefab, transform.position, Quaternion.identity);\n        }\n\n        // Damage nearby objects\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, explosionRadius, damageLayers);\n        foreach (Collider hitCollider in hitColliders)\n        {\n            IDamageable damageable = hitCollider.GetComponent<IDamageable>();\n            if (damageable != null)\n            {\n                damageable.TakeDamage(explosionDamage);\n            }\n        }\n\n        // Destroy enemy object\n        Destroy(gameObject);\n    }\n\n    // Optional: Visualize explosion radius in editor\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, explosionRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Spaceship\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxThrust\",\n      \"type\": \"float\",\n      \"default\": 500\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"currentFuel\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"fuelConsumptionRate\",\n      \"type\": \"float\",\n      \"default\": 10\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"apply_forward_thrust\",\n      \"trigger\": \"player presses forward acceleration button\",\n      \"actions\": [\n        {\n          \"action\": \"apply thrust in current spaceship direction\"\n        },\n        {\n          \"action\": \"reduce current fuel amount\"\n        },\n        {\n          \"action\": \"play engine thrust sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rotate_left\",\n      \"trigger\": \"player presses left rotation control\",\n      \"actions\": [\n        {\n          \"action\": \"rotate spaceship counter-clockwise\"\n        },\n        {\n          \"action\": \"reduce rotation speed gradually\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rotate_right\",\n      \"trigger\": \"player presses right rotation control\",\n      \"actions\": [\n        {\n          \"action\": \"rotate spaceship clockwise\"\n        },\n        {\n          \"action\": \"reduce rotation speed gradually\"\n        }\n      ]\n    },\n    {\n      \"name\": \"check_fuel_depletion\",\n      \"trigger\": \"current fuel reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"disable thrust controls\"\n        },\n        {\n          \"action\": \"play out of fuel warning sound\"\n        },\n        {\n          \"action\": \"trigger spaceship drift mode\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SpaceshipController : MonoBehaviour\n{\n    [Header(\"Thrust Settings\")]\n    [SerializeField] private float maxThrust = 10f;\n    [SerializeField] private float rotationSpeed = 100f;\n    [SerializeField] private float thrustAcceleration = 5f;\n\n    [Header(\"Input Settings\")]\n    [SerializeField] private KeyCode thrustKey = KeyCode.W;\n    [SerializeField] private KeyCode rotateLeftKey = KeyCode.A;\n    [SerializeField] private KeyCode rotateRightKey = KeyCode.D;\n\n    private Rigidbody2D rb;\n    private float currentThrust = 0f;\n\n    private void Start()\n    {\n        // Get the Rigidbody2D component\n        rb = GetComponent<Rigidbody2D>();\n\n        // Ensure Rigidbody2D is not null\n        if (rb == null)\n        {\n            Debug.LogError(\"Rigidbody2D component is missing on the spaceship!\");\n        }\n    }\n\n    private void Update()\n    {\n        // Handle rotation input\n        HandleRotation();\n    }\n\n    private void FixedUpdate()\n    {\n        // Handle thrust physics in FixedUpdate\n        HandleThrust();\n    }\n\n    private void HandleRotation()\n    {\n        // Rotate left\n        if (Input.GetKey(rotateLeftKey))\n        {\n            transform.Rotate(Vector3.forward * rotationSpeed * Time.deltaTime);\n        }\n\n        // Rotate right\n        if (Input.GetKey(rotateRightKey))\n        {\n            transform.Rotate(Vector3.back * rotationSpeed * Time.deltaTime);\n        }\n    }\n\n    private void HandleThrust()\n    {\n        // Apply thrust when thrust key is held\n        if (Input.GetKey(thrustKey))\n        {\n            // Gradually increase thrust\n            currentThrust = Mathf.Lerp(currentThrust, maxThrust, thrustAcceleration * Time.fixedDeltaTime);\n        }\n        else\n        {\n            // Gradually decrease thrust when not accelerating\n            currentThrust = Mathf.Lerp(currentThrust, 0f, thrustAcceleration * Time.fixedDeltaTime);\n        }\n\n        // Apply thrust in the direction the spaceship is facing\n        if (rb != null)\n        {\n            rb.AddForce(transform.up * currentThrust, ForceMode2D.Force);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FloatingBoat\",\n  \"components\": [\n    \"Rigidbody\",\n    \"BoxCollider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"floatHeight\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"stabilityFactor\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    },\n    {\n      \"name\": \"waterLevel\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"float_on_surface\",\n      \"trigger\": \"boat is above water surface\",\n      \"actions\": [\n        {\n          \"action\": \"gently bob up and down with water waves\"\n        },\n        {\n          \"action\": \"maintain horizontal orientation\"\n        },\n        {\n          \"action\": \"prevent boat from sinking completely\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_water_collision\",\n      \"trigger\": \"boat touches water surface\",\n      \"actions\": [\n        {\n          \"action\": \"adjust vertical position to match water level\"\n        },\n        {\n          \"action\": \"reduce vertical velocity\"\n        },\n        {\n          \"action\": \"create gentle splashing effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"drift_with_current\",\n      \"trigger\": \"no player input detected\",\n      \"actions\": [\n        {\n          \"action\": \"move slowly in direction of water current\"\n        },\n        {\n          \"action\": \"apply subtle rocking motion\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class BoatController : MonoBehaviour\n{\n    [SerializeField] private float waterLevel = 0f;\n    [SerializeField] private float floatHeight = 1f;\n    [SerializeField] private float floatForce = 10f;\n    [SerializeField] private float wobbleAmount = 0.1f;\n    [SerializeField] private float wobbleSpeed = 2f;\n\n    private Rigidbody rb;\n    private Vector3 originalPosition;\n\n    private void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        \n        if (rb == null)\n        {\n            Debug.LogError(\"Rigidbody component required for boat flotation\");\n            enabled = false;\n            return;\n        }\n\n        originalPosition = transform.position;\n        rb.useGravity = true;\n    }\n\n    private void FixedUpdate()\n    {\n        ApplyFloatation();\n        ApplyWobbleEffect();\n    }\n\n    private void ApplyFloatation()\n    {\n        float distanceAboveWater = transform.position.y - waterLevel;\n\n        if (distanceAboveWater < floatHeight)\n        {\n            float submersionPercentage = 1f - (distanceAboveWater / floatHeight);\n            Vector3 floatForceVector = Vector3.up * floatForce * submersionPercentage;\n            \n            rb.AddForce(floatForceVector, ForceMode.Acceleration);\n        }\n    }\n\n    private void ApplyWobbleEffect()\n    {\n        float wobbleX = Mathf.Sin(Time.time * wobbleSpeed) * wobbleAmount;\n        float wobbleZ = Mathf.Cos(Time.time * wobbleSpeed) * wobbleAmount;\n\n        transform.position = originalPosition + new Vector3(wobbleX, 0, wobbleZ);\n    }\n\n    public void SetWaterLevel(float newWaterLevel)\n    {\n        waterLevel = newWaterLevel;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"EnemyPatroller\",\n  \"components\": [\n    \"NavMeshAgent\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"waypoints\",\n      \"type\": \"Transform[]\",\n      \"default\": []\n    },\n    {\n      \"name\": \"currentWaypointIndex\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"patrolSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    },\n    {\n      \"name\": \"waitTimeAtWaypoint\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"patrol_waypoints\",\n      \"trigger\": \"when enemy starts or completes movement to current waypoint\",\n      \"actions\": [\n        {\n          \"action\": \"select next waypoint in patrol route\"\n        },\n        {\n          \"action\": \"move toward selected waypoint at patrol speed\"\n        },\n        {\n          \"action\": \"pause and wait for specified duration at each waypoint\"\n        }\n      ]\n    },\n    {\n      \"name\": \"change_waypoint_direction\",\n      \"trigger\": \"when enemy reaches last waypoint in route\",\n      \"actions\": [\n        {\n          \"action\": \"reverse patrol route direction\"\n        },\n        {\n          \"action\": \"continue patrolling in opposite direction\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class EnemyPatrol : MonoBehaviour\n{\n    [SerializeField] private Transform[] waypoints;\n    [SerializeField] private float moveSpeed = 3f;\n    [SerializeField] private float waypointWaitTime = 1f;\n\n    private int currentWaypointIndex = 0;\n    private bool isWaiting = false;\n    private float waitTimer = 0f;\n\n    private void Start()\n    {\n        if (waypoints == null || waypoints.Length == 0)\n        {\n            Debug.LogError(\"No waypoints assigned to enemy patrol!\");\n            enabled = false;\n        }\n    }\n\n    private void Update()\n    {\n        if (waypoints.Length <= 1) return;\n\n        if (isWaiting)\n        {\n            WaitAtWaypoint();\n            return;\n        }\n\n        MoveToNextWaypoint();\n    }\n\n    private void MoveToNextWaypoint()\n    {\n        Transform targetWaypoint = waypoints[currentWaypointIndex];\n        transform.position = Vector3.MoveTowards(transform.position, targetWaypoint.position, moveSpeed * Time.deltaTime);\n\n        // Rotate to face movement direction\n        Vector3 moveDirection = (targetWaypoint.position - transform.position).normalized;\n        if (moveDirection != Vector3.zero)\n        {\n            transform.rotation = Quaternion.LookRotation(moveDirection);\n        }\n\n        // Check if reached waypoint\n        if (Vector3.Distance(transform.position, targetWaypoint.position) < 0.1f)\n        {\n            isWaiting = true;\n            waitTimer = 0f;\n            currentWaypointIndex = (currentWaypointIndex + 1) % waypoints.Length;\n        }\n    }\n\n    private void WaitAtWaypoint()\n    {\n        waitTimer += Time.deltaTime;\n\n        if (waitTimer >= waypointWaitTime)\n        {\n            isWaiting = false;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PlayerDashAbility\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"dashSpeed\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"dashDuration\",\n      \"type\": \"float\",\n      \"default\": 0.2\n    },\n    {\n      \"name\": \"dashCooldown\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"currentCooldownTimer\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"dash_ability\",\n      \"trigger\": \"player presses dash input button\",\n      \"actions\": [\n        {\n          \"action\": \"check if dash is not on cooldown\"\n        },\n        {\n          \"action\": \"launch player quickly in current movement direction\"\n        },\n        {\n          \"action\": \"play dash sound effect\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        },\n        {\n          \"action\": \"become temporarily invulnerable\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cooldown_management\",\n      \"trigger\": \"dash ability is on cooldown\",\n      \"actions\": [\n        {\n          \"action\": \"gradually reduce cooldown timer\"\n        },\n        {\n          \"action\": \"prevent additional dash attempts\"\n        },\n        {\n          \"action\": \"reset dash ability when timer reaches zero\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class DashAbility : MonoBehaviour\n{\n    [SerializeField] private float dashForce = 10f;\n    [SerializeField] private float dashDuration = 0.2f;\n    [SerializeField] private float dashCooldown = 1f;\n\n    [Header(\"Input Settings\")]\n    [SerializeField] private KeyCode dashKey = KeyCode.LeftShift;\n\n    private Rigidbody2D rb;\n    private bool canDash = true;\n    private bool isDashing = false;\n    private float dashTimeRemaining;\n    private float dashCooldownTimeRemaining;\n\n    private void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        \n        if (rb == null)\n        {\n            Debug.LogError(\"Rigidbody2D component not found on player!\");\n        }\n    }\n\n    private void Update()\n    {\n        HandleDashInput();\n        UpdateDashCooldown();\n    }\n\n    private void HandleDashInput()\n    {\n        if (Input.GetKeyDown(dashKey) && canDash)\n        {\n            StartDash();\n        }\n    }\n\n    private void StartDash()\n    {\n        isDashing = true;\n        canDash = false;\n        dashTimeRemaining = dashDuration;\n\n        // Get current movement direction or facing direction\n        Vector2 dashDirection = GetDashDirection();\n        rb.velocity = dashDirection * dashForce;\n    }\n\n    private Vector2 GetDashDirection()\n    {\n        // Use current input direction or last movement direction\n        float horizontalInput = Input.GetAxisRaw(\"Horizontal\");\n        float verticalInput = Input.GetAxisRaw(\"Vertical\");\n\n        Vector2 direction = new Vector2(horizontalInput, verticalInput).normalized;\n        return direction != Vector2.zero ? direction : transform.right;\n    }\n\n    private void UpdateDashCooldown()\n    {\n        // Manage dash duration\n        if (isDashing)\n        {\n            dashTimeRemaining -= Time.deltaTime;\n            if (dashTimeRemaining <= 0)\n            {\n                StopDash();\n            }\n        }\n\n        // Manage dash cooldown\n        if (!canDash)\n        {\n            dashCooldownTimeRemaining -= Time.deltaTime;\n            if (dashCooldownTimeRemaining <= 0)\n            {\n                ResetDash();\n            }\n        }\n    }\n\n    private void StopDash()\n    {\n        isDashing = false;\n        rb.velocity = Vector2.zero;\n        dashCooldownTimeRemaining = dashCooldown;\n    }\n\n    private void ResetDash()\n    {\n        canDash = true;\n        dashCooldownTimeRemaining = 0;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GrapplingHook\",\n  \"components\": [\n    \"LineRenderer\",\n    \"AudioSource\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"hookRange\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"pullSpeed\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"maxHookDistance\",\n      \"type\": \"float\",\n      \"default\": 100\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"aim_grappling_hook\",\n      \"trigger\": \"player presses grappling hook activation button\",\n      \"actions\": [\n        {\n          \"action\": \"cast a line in aiming direction\"\n        },\n        {\n          \"action\": \"check if line hits valid grapple surface\"\n        },\n        {\n          \"action\": \"show visual line renderer preview\"\n        }\n      ]\n    },\n    {\n      \"name\": \"attach_to_surface\",\n      \"trigger\": \"grapple line successfully connects to surface\",\n      \"actions\": [\n        {\n          \"action\": \"lock grapple point location\"\n        },\n        {\n          \"action\": \"play grapple attachment sound\"\n        },\n        {\n          \"action\": \"start pulling player toward grapple point\"\n        }\n      ]\n    },\n    {\n      \"name\": \"pull_player\",\n      \"trigger\": \"grapple point is successfully locked\",\n      \"actions\": [\n        {\n          \"action\": \"smoothly move player toward grapple point\"\n        },\n        {\n          \"action\": \"adjust player velocity based on distance\"\n        },\n        {\n          \"action\": \"stop pulling when player reaches grapple point\"\n        }\n      ]\n    },\n    {\n      \"name\": \"release_grapple\",\n      \"trigger\": \"player releases grappling hook button or reaches grapple point\",\n      \"actions\": [\n        {\n          \"action\": \"detach line renderer\"\n        },\n        {\n          \"action\": \"reset player momentum\"\n        },\n        {\n          \"action\": \"play grapple release sound\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class GrapplingHook : MonoBehaviour\n{\n    [SerializeField] private Camera playerCamera;\n    [SerializeField] private LayerMask grapplableLayer;\n    [SerializeField] private float maxGrappleDistance = 50f;\n    [SerializeField] private float grappleSpeed = 15f;\n    [SerializeField] private float grapplePullForce = 10f;\n\n    [Header(\"References\")]\n    [SerializeField] private Transform gunTip;\n    [SerializeField] private LineRenderer grappleLine;\n\n    private Rigidbody playerRigidbody;\n    private SpringJoint grappleJoint;\n    private Vector3 grapplePoint;\n    private bool isGrappling = false;\n\n    private void Start()\n    {\n        playerRigidbody = GetComponent<Rigidbody>();\n        grappleLine.enabled = false;\n    }\n\n    private void Update()\n    {\n        // Check for grapple input\n        if (Input.GetMouseButtonDown(0))\n        {\n            StartGrapple();\n        }\n\n        if (Input.GetMouseButtonUp(0))\n        {\n            StopGrapple();\n        }\n\n        // Update grapple line if grappling\n        if (isGrappling)\n        {\n            UpdateGrappleLine();\n        }\n    }\n\n    private void StartGrapple()\n    {\n        // Raycast to find grapple point\n        RaycastHit hit;\n        if (Physics.Raycast(playerCamera.transform.position, playerCamera.transform.forward, \n            out hit, maxGrappleDistance, grapplableLayer))\n        {\n            grapplePoint = hit.point;\n            isGrappling = true;\n\n            // Create spring joint for grapple physics\n            grappleJoint = gameObject.AddComponent<SpringJoint>();\n            grappleJoint.autoConfigureConnectedAnchor = false;\n            grappleJoint.connectedAnchor = grapplePoint;\n            grappleJoint.spring = grapplePullForce;\n            grappleJoint.damper = 4.5f;\n            grappleJoint.massScale = 4.5f;\n\n            // Enable and position grapple line\n            grappleLine.enabled = true;\n        }\n    }\n\n    private void UpdateGrappleLine()\n    {\n        // Draw line between player and grapple point\n        grappleLine.SetPosition(0, gunTip.position);\n        grappleLine.SetPosition(1, grapplePoint);\n    }\n\n    private void StopGrapple()\n    {\n        // Reset grapple state\n        isGrappling = false;\n        grappleLine.enabled = false;\n\n        // Remove spring joint\n        if (grappleJoint != null)\n        {\n            Destroy(grappleJoint);\n        }\n    }\n\n    private void FixedUpdate()\n    {\n        // Optional: Add custom grapple movement logic\n        if (isGrappling)\n        {\n            Vector3 directionToGrapple = (grapplePoint - transform.position).normalized;\n            playerRigidbody.AddForce(directionToGrapple * grappleSpeed, ForceMode.Acceleration);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"VehicleController\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxSpeed\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"acceleration\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"steeringSpeed\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"currentSpeed\",\n      \"type\": \"float\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"accelerate\",\n      \"trigger\": \"player presses forward acceleration input\",\n      \"actions\": [\n        {\n          \"action\": \"gradually increase current speed toward max speed\"\n        },\n        {\n          \"action\": \"apply forward momentum to vehicle\"\n        }\n      ]\n    },\n    {\n      \"name\": \"brake\",\n      \"trigger\": \"player presses brake input\",\n      \"actions\": [\n        {\n          \"action\": \"gradually reduce current speed\"\n        },\n        {\n          \"action\": \"apply reverse momentum to vehicle\"\n        }\n      ]\n    },\n    {\n      \"name\": \"steer_left\",\n      \"trigger\": \"player presses left steering input\",\n      \"actions\": [\n        {\n          \"action\": \"rotate vehicle toward left side\"\n        },\n        {\n          \"action\": \"adjust vehicle heading smoothly\"\n        }\n      ]\n    },\n    {\n      \"name\": \"steer_right\",\n      \"trigger\": \"player presses right steering input\",\n      \"actions\": [\n        {\n          \"action\": \"rotate vehicle toward right side\"\n        },\n        {\n          \"action\": \"adjust vehicle heading smoothly\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class CarController : MonoBehaviour\n{\n    [Header(\"Car Settings\")]\n    [SerializeField] private float motorForce = 1000f;\n    [SerializeField] private float steerAngle = 30f;\n    [SerializeField] private float brakeForce = 3000f;\n\n    [Header(\"Wheel References\")]\n    [SerializeField] private WheelCollider frontLeftWheel;\n    [SerializeField] private WheelCollider frontRightWheel;\n    [SerializeField] private WheelCollider rearLeftWheel;\n    [SerializeField] private WheelCollider rearRightWheel;\n\n    private float horizontalInput;\n    private float verticalInput;\n    private float currentbrakeForce;\n    private bool isBraking;\n\n    private void Update()\n    {\n        // Get input from player\n        GetInput();\n    }\n\n    private void FixedUpdate()\n    {\n        // Apply car movement and steering\n        HandleMotor();\n        HandleSteering();\n    }\n\n    private void GetInput()\n    {\n        horizontalInput = Input.GetAxis(\"Horizontal\");\n        verticalInput = Input.GetAxis(\"Vertical\");\n        isBraking = Input.GetKey(KeyCode.Space);\n    }\n\n    private void HandleMotor()\n    {\n        // Apply acceleration to rear wheels\n        rearLeftWheel.motorTorque = verticalInput * motorForce;\n        rearRightWheel.motorTorque = verticalInput * motorForce;\n\n        // Apply braking\n        currentbrakeForce = isBraking ? brakeForce : 0f;\n        ApplyBraking();\n    }\n\n    private void ApplyBraking()\n    {\n        frontLeftWheel.brakeTorque = currentbrakeForce;\n        frontRightWheel.brakeTorque = currentbrakeForce;\n        rearLeftWheel.brakeTorque = currentbrakeForce;\n        rearRightWheel.brakeTorque = currentbrakeForce;\n    }\n\n    private void HandleSteering()\n    {\n        // Apply steering to front wheels\n        frontLeftWheel.steerAngle = horizontalInput * steerAngle;\n        frontRightWheel.steerAngle = horizontalInput * steerAngle;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RocketLauncher\",\n  \"components\": [\n    \"Weapon\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"damage\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"splashRadius\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"rocketPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"fireRate\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"fire_rocket\",\n      \"trigger\": \"when player presses fire button\",\n      \"actions\": [\n        {\n          \"action\": \"spawn rocket projectile from weapon barrel\"\n        },\n        {\n          \"action\": \"apply forward momentum to rocket\"\n        },\n        {\n          \"action\": \"play rocket launch sound\"\n        },\n        {\n          \"action\": \"create muzzle flash particle effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"rocket_explosion\",\n      \"trigger\": \"when rocket collides with environment or target\",\n      \"actions\": [\n        {\n          \"action\": \"create large explosion effect\"\n        },\n        {\n          \"action\": \"deal damage to all objects within splash radius\"\n        },\n        {\n          \"action\": \"apply radial force to nearby objects\"\n        },\n        {\n          \"action\": \"play loud explosion sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"weapon_cooldown\",\n      \"trigger\": \"after rocket is fired\",\n      \"actions\": [\n        {\n          \"action\": \"disable firing for set duration\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class RocketLauncher : MonoBehaviour\n{\n    [SerializeField] private GameObject rocketPrefab;\n    [SerializeField] private Transform firePoint;\n    [SerializeField] private float rocketSpeed = 20f;\n    [SerializeField] private float splashRadius = 5f;\n    [SerializeField] private float splashDamage = 50f;\n    [SerializeField] private float fireRate = 1f;\n\n    private float nextFireTime = 0f;\n\n    private void Update()\n    {\n        // Check for fire input\n        if (Input.GetButton(\"Fire1\") && Time.time >= nextFireTime)\n        {\n            FireRocket();\n        }\n    }\n\n    private void FireRocket()\n    {\n        // Validate rocket prefab and fire point\n        if (rocketPrefab == null || firePoint == null)\n        {\n            Debug.LogWarning(\"Rocket launcher is not properly configured!\");\n            return;\n        }\n\n        // Instantiate rocket at fire point\n        GameObject rocket = Instantiate(rocketPrefab, firePoint.position, firePoint.rotation);\n        \n        // Add velocity to rocket\n        Rigidbody rocketRb = rocket.GetComponent<Rigidbody>();\n        if (rocketRb != null)\n        {\n            rocketRb.velocity = firePoint.forward * rocketSpeed;\n        }\n\n        // Set next fire time\n        nextFireTime = Time.time + 1f / fireRate;\n\n        // Attach explosion behavior\n        RocketExplosion explosionScript = rocket.AddComponent<RocketExplosion>();\n        explosionScript.splashRadius = splashRadius;\n        explosionScript.splashDamage = splashDamage;\n    }\n}\n\npublic class RocketExplosion : MonoBehaviour\n{\n    public float splashRadius = 5f;\n    public float splashDamage = 50f;\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        // Perform splash damage\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, splashRadius);\n        \n        foreach (Collider hitCollider in hitColliders)\n        {\n            // Check for damageable objects\n            IDamageable damageableObject = hitCollider.GetComponent<IDamageable>();\n            if (damageableObject != null)\n            {\n                // Calculate distance-based damage falloff\n                float distance = Vector3.Distance(transform.position, hitCollider.transform.position);\n                float damageMultiplier = 1f - (distance / splashRadius);\n                float finalDamage = splashDamage * damageMultiplier;\n\n                damageableObject.TakeDamage(finalDamage);\n            }\n        }\n\n        // Optional: Add explosion visual effect\n        CreateExplosionEffect();\n\n        // Destroy rocket\n        Destroy(gameObject);\n    }\n\n    private void CreateExplosionEffect()\n    {\n        // Placeholder for explosion particle system or effect\n    }\n}\n\npublic interface IDamageable\n{\n    void TakeDamage(float damage);\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Flamethrower\",\n  \"components\": [\n    \"ParticleSystem\",\n    \"AudioSource\",\n    \"LineRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"fireRange\",\n      \"type\": \"float\",\n      \"default\": 15.0\n    },\n    {\n      \"name\": \"damage\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"heatIntensity\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"fuelCapacity\",\n      \"type\": \"float\",\n      \"default\": 100.0\n    },\n    {\n      \"name\": \"currentFuel\",\n      \"type\": \"float\",\n      \"default\": 100.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"fire_weapon\",\n      \"trigger\": \"when player holds fire button\",\n      \"actions\": [\n        {\n          \"action\": \"emit continuous flame particles\"\n        },\n        {\n          \"action\": \"play burning sound effect\"\n        },\n        {\n          \"action\": \"reduce current fuel amount\"\n        },\n        {\n          \"action\": \"create heat damage zone in front of weapon\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_firing\",\n      \"trigger\": \"when player releases fire button\",\n      \"actions\": [\n        {\n          \"action\": \"stop particle emission\"\n        },\n        {\n          \"action\": \"stop burning sound\"\n        },\n        {\n          \"action\": \"disable heat damage zone\"\n        }\n      ]\n    },\n    {\n      \"name\": \"refuel_weapon\",\n      \"trigger\": \"when current fuel is below 20 percent\",\n      \"actions\": [\n        {\n          \"action\": \"show low fuel warning\"\n        },\n        {\n          \"action\": \"prevent further firing\"\n        },\n        {\n          \"action\": \"request player reload fuel tank\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class Flamethrower : MonoBehaviour\n{\n    [Header(\"Flame Settings\")]\n    [SerializeField] private ParticleSystem flameParticleSystem;\n    [SerializeField] private float maxFlameRange = 10f;\n    [SerializeField] private float damagePerSecond = 5f;\n    [SerializeField] private float fuelCapacity = 10f;\n    [SerializeField] private float heatCooldownRate = 1f;\n\n    [Header(\"Input\")]\n    [SerializeField] private KeyCode fireButton = KeyCode.Mouse0;\n\n    private float currentFuel;\n    private bool isFiring;\n    private float currentHeat;\n\n    private void Start()\n    {\n        // Initialize fuel to full capacity\n        currentFuel = fuelCapacity;\n\n        // Ensure particle system is assigned\n        if (flameParticleSystem == null)\n        {\n            Debug.LogError(\"Flame Particle System is not assigned!\");\n        }\n    }\n\n    private void Update()\n    {\n        HandleInput();\n        UpdateFlamethrower();\n    }\n\n    private void HandleInput()\n    {\n        // Check if fire button is pressed and has fuel\n        isFiring = Input.GetKey(fireButton) && currentFuel > 0;\n    }\n\n    private void UpdateFlamethrower()\n    {\n        if (isFiring)\n        {\n            // Consume fuel while firing\n            currentFuel -= Time.deltaTime;\n            currentHeat += Time.deltaTime;\n\n            // Start particle system if not already playing\n            if (!flameParticleSystem.isPlaying)\n            {\n                flameParticleSystem.Play();\n            }\n\n            // Perform raycast damage\n            PerformFlameDamage();\n        }\n        else\n        {\n            // Stop particle system when not firing\n            if (flameParticleSystem.isPlaying)\n            {\n                flameParticleSystem.Stop();\n            }\n\n            // Cool down heat\n            currentHeat = Mathf.Max(0, currentHeat - heatCooldownRate * Time.deltaTime);\n        }\n\n        // Regenerate fuel slowly when not firing\n        if (!isFiring)\n        {\n            currentFuel = Mathf.Min(fuelCapacity, currentFuel + Time.deltaTime);\n        }\n    }\n\n    private void PerformFlameDamage()\n    {\n        RaycastHit[] hits = Physics.RaycastAll(transform.position, transform.forward, maxFlameRange);\n\n        foreach (RaycastHit hit in hits)\n        {\n            // Check for damageable objects\n            IDamageable damageable = hit.collider.GetComponent<IDamageable>();\n            if (damageable != null)\n            {\n                damageable.TakeDamage(damagePerSecond * Time.deltaTime);\n            }\n        }\n    }\n\n    // Optional interface for damage handling\n    public interface IDamageable\n    {\n        void TakeDamage(float damage);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AreaMusicController\",\n  \"components\": [\n    \"AudioSource\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"musicTracks\",\n      \"type\": \"AudioClip[]\",\n      \"default\": []\n    },\n    {\n      \"name\": \"currentArea\",\n      \"type\": \"string\",\n      \"default\": \"\"\n    },\n    {\n      \"name\": \"musicVolume\",\n      \"type\": \"float\",\n      \"default\": 0.7\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"enter_area_music_change\",\n      \"trigger\": \"when player enters a new area trigger zone\",\n      \"actions\": [\n        {\n          \"action\": \"determine current area name\"\n        },\n        {\n          \"action\": \"select matching music track for this area\"\n        },\n        {\n          \"action\": \"fade out previous music\"\n        },\n        {\n          \"action\": \"play new area's background music\"\n        }\n      ]\n    },\n    {\n      \"name\": \"smooth_music_transition\",\n      \"trigger\": \"during area music change\",\n      \"actions\": [\n        {\n          \"action\": \"gradually decrease volume of current music\"\n        },\n        {\n          \"action\": \"smoothly increase volume of new music track\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class AreaMusicController : MonoBehaviour\n{\n    [System.Serializable]\n    public class AreaMusicMapping\n    {\n        public string areaName;\n        public AudioClip musicTrack;\n    }\n\n    [SerializeField] private List<AreaMusicMapping> areaMusicMappings;\n    [SerializeField] private AudioSource musicSource;\n\n    private string currentArea;\n\n    private void Start()\n    {\n        // Ensure audio source is assigned\n        if (musicSource == null)\n        {\n            musicSource = gameObject.AddComponent<AudioSource>();\n            musicSource.loop = true;\n        }\n    }\n\n    public void ChangeArea(string newArea)\n    {\n        // Prevent unnecessary music changes\n        if (newArea == currentArea) return;\n\n        AudioClip newTrack = FindMusicForArea(newArea);\n        \n        if (newTrack != null)\n        {\n            musicSource.clip = newTrack;\n            musicSource.Play();\n            currentArea = newArea;\n        }\n    }\n\n    private AudioClip FindMusicForArea(string areaName)\n    {\n        // Find matching music track for area\n        AreaMusicMapping mapping = areaMusicMappings.Find(m => m.areaName == areaName);\n        return mapping?.musicTrack;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"TankController\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 45\n    },\n    {\n      \"name\": \"turretRotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"detectionRadius\",\n      \"type\": \"float\",\n      \"default\": 20\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"track_target\",\n      \"trigger\": \"when enemy is within detection radius\",\n      \"actions\": [\n        {\n          \"action\": \"smoothly rotate turret toward detected enemy\"\n        },\n        {\n          \"action\": \"limit turret rotation to reasonable angle range\"\n        }\n      ]\n    },\n    {\n      \"name\": \"idle_turret_behavior\",\n      \"trigger\": \"when no enemy is detected\",\n      \"actions\": [\n        {\n          \"action\": \"slowly scan surrounding area with turret\"\n        },\n        {\n          \"action\": \"return turret to default neutral position\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class TankController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float moveSpeed = 5f;\n    [SerializeField] private float rotationSpeed = 100f;\n\n    [Header(\"Turret Settings\")]\n    [SerializeField] private Transform turretTransform;\n    [SerializeField] private float turretRotationSpeed = 75f;\n\n    [Header(\"Input\")]\n    [SerializeField] private KeyCode forwardKey = KeyCode.W;\n    [SerializeField] private KeyCode backwardKey = KeyCode.S;\n    [SerializeField] private KeyCode turnLeftKey = KeyCode.A;\n    [SerializeField] private KeyCode turnRightKey = KeyCode.D;\n\n    private Rigidbody rb;\n    private Camera mainCamera;\n\n    private void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        mainCamera = Camera.main;\n\n        if (turretTransform == null)\n        {\n            Debug.LogError(\"Turret transform is not assigned!\");\n        }\n    }\n\n    private void Update()\n    {\n        HandleTurretRotation();\n    }\n\n    private void FixedUpdate()\n    {\n        HandleMovement();\n    }\n\n    private void HandleMovement()\n    {\n        float verticalInput = 0f;\n        float horizontalRotation = 0f;\n\n        if (Input.GetKey(forwardKey))\n            verticalInput = moveSpeed;\n        else if (Input.GetKey(backwardKey))\n            verticalInput = -moveSpeed;\n\n        if (Input.GetKey(turnLeftKey))\n            horizontalRotation = -rotationSpeed;\n        else if (Input.GetKey(turnRightKey))\n            horizontalRotation = rotationSpeed;\n\n        // Move tank forward/backward\n        rb.MovePosition(rb.position + transform.forward * verticalInput * Time.fixedDeltaTime);\n\n        // Rotate tank\n        rb.MoveRotation(rb.rotation * Quaternion.Euler(Vector3.up * horizontalRotation * Time.fixedDeltaTime));\n    }\n\n    private void HandleTurretRotation()\n    {\n        if (turretTransform == null) return;\n\n        // Get mouse position in world space\n        Ray ray = mainCamera.ScreenPointToRay(Input.mousePosition);\n        Plane groundPlane = new Plane(Vector3.up, transform.position);\n\n        if (groundPlane.Raycast(ray, out float distance))\n        {\n            Vector3 targetPoint = ray.GetPoint(distance);\n            Vector3 targetDirection = targetPoint - turretTransform.position;\n            targetDirection.y = 0; // Keep rotation on horizontal plane\n\n            if (targetDirection != Vector3.zero)\n            {\n                Quaternion targetRotation = Quaternion.LookRotation(targetDirection);\n                turretTransform.rotation = Quaternion.Slerp(\n                    turretTransform.rotation, \n                    targetRotation, \n                    turretRotationSpeed * Time.deltaTime\n                );\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PoisonGasCloud\",\n  \"components\": [\n    \"Collider\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"damagePerSecond\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"cloudRadius\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"lifetimeDuration\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"spawn_cloud\",\n      \"trigger\": \"when gas cloud is instantiated\",\n      \"actions\": [\n        {\n          \"action\": \"start particle system emission\"\n        },\n        {\n          \"action\": \"begin countdown for cloud destruction\"\n        }\n      ]\n    },\n    {\n      \"name\": \"damage_entities\",\n      \"trigger\": \"when living entity remains inside gas cloud\",\n      \"actions\": [\n        {\n          \"action\": \"apply damage to entity over time\"\n        },\n        {\n          \"action\": \"create visual effect of poisoning\"\n        }\n      ]\n    },\n    {\n      \"name\": \"expire_cloud\",\n      \"trigger\": \"when cloud lifetime duration is complete\",\n      \"actions\": [\n        {\n          \"action\": \"stop particle system\"\n        },\n        {\n          \"action\": \"destroy gas cloud object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class PoisonGasCloud : MonoBehaviour\n{\n    [SerializeField] private float damageAmount = 10f;\n    [SerializeField] private float damageInterval = 1f;\n    [SerializeField] private float cloudRadius = 5f;\n    [SerializeField] private LayerMask targetLayers;\n\n    private float nextDamageTime;\n\n    private void Start()\n    {\n        // Initialize first damage time\n        nextDamageTime = Time.time;\n    }\n\n    private void Update()\n    {\n        // Check for targets in cloud radius at damage intervals\n        if (Time.time >= nextDamageTime)\n        {\n            ApplyDamageToTargets();\n            nextDamageTime = Time.time + damageInterval;\n        }\n    }\n\n    private void ApplyDamageToTargets()\n    {\n        // Find all colliders within cloud radius\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, cloudRadius, targetLayers);\n\n        foreach (Collider hitCollider in hitColliders)\n        {\n            // Try to get health component\n            IDamageable damageable = hitCollider.GetComponent<IDamageable>();\n            \n            if (damageable != null)\n            {\n                damageable.TakeDamage(damageAmount);\n            }\n        }\n    }\n\n    // Optional: Visualize cloud radius in editor\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, cloudRadius);\n    }\n}\n\n// Recommended companion interface\npublic interface IDamageable\n{\n    void TakeDamage(float damage);\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"WindZone\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"windStrength\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"windRadius\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    },\n    {\n      \"name\": \"windDirection\",\n      \"type\": \"string\",\n      \"default\": \"horizontal\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"push_objects\",\n      \"trigger\": \"when any physics object enters wind zone area\",\n      \"actions\": [\n        {\n          \"action\": \"apply continuous pushing force to detected object\"\n        },\n        {\n          \"action\": \"push object in current wind direction\"\n        },\n        {\n          \"action\": \"scale push intensity based on wind strength\"\n        }\n      ]\n    },\n    {\n      \"name\": \"wind_sound_effect\",\n      \"trigger\": \"when wind is actively pushing objects\",\n      \"actions\": [\n        {\n          \"action\": \"play subtle whooshing audio\"\n        },\n        {\n          \"action\": \"adjust audio volume based on wind strength\"\n        }\n      ]\n    },\n    {\n      \"name\": \"visual_wind_indication\",\n      \"trigger\": \"continuously while wind zone is active\",\n      \"actions\": [\n        {\n          \"action\": \"create subtle particle effects showing wind movement\"\n        },\n        {\n          \"action\": \"animate nearby lightweight objects like leaves or grass\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class WindZone : MonoBehaviour\n{\n    [SerializeField] private float windStrength = 10f;\n    [SerializeField] private Vector3 windDirection = Vector3.right;\n    [SerializeField] private float windRadius = 5f;\n    [SerializeField] private bool debugVisualize = false;\n\n    private void OnTriggerStay(Collider other)\n    {\n        // Check if object has rigidbody to apply force\n        Rigidbody rb = other.GetComponent<Rigidbody>();\n        if (rb != null)\n        {\n            // Apply wind force proportional to object's mass\n            rb.AddForce(windDirection.normalized * windStrength * rb.mass, ForceMode.Force);\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        // Optional debug visualization in scene view\n        if (debugVisualize)\n        {\n            Gizmos.color = Color.blue;\n            Gizmos.DrawWireSphere(transform.position, windRadius);\n            Gizmos.DrawRay(transform.position, windDirection * windRadius);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HomingMissile\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"moveSpeed\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"turnRate\",\n      \"type\": \"float\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"maxLifetime\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"currentTarget\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"explosionRadius\",\n      \"type\": \"float\",\n      \"default\": 5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"launch_missile\",\n      \"trigger\": \"when missile is first instantiated\",\n      \"actions\": [\n        {\n          \"action\": \"start moving forward at constant speed\"\n        },\n        {\n          \"action\": \"begin tracking nearest valid target\"\n        },\n        {\n          \"action\": \"start lifetime countdown timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"track_target\",\n      \"trigger\": \"while target is detected and missile is active\",\n      \"actions\": [\n        {\n          \"action\": \"smoothly rotate toward current target\"\n        },\n        {\n          \"action\": \"continuously adjust flight path to intercept target\"\n        },\n        {\n          \"action\": \"maintain constant forward velocity\"\n        }\n      ]\n    },\n    {\n      \"name\": \"missile_destruction\",\n      \"trigger\": \"when missile exceeds maximum lifetime or collides with object\",\n      \"actions\": [\n        {\n          \"action\": \"create explosion effect at current position\"\n        },\n        {\n          \"action\": \"apply damage to nearby objects\"\n        },\n        {\n          \"action\": \"play explosion sound\"\n        },\n        {\n          \"action\": \"destroy missile game object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class HomingMissile : MonoBehaviour\n{\n    [SerializeField] private float speed = 10f;\n    [SerializeField] private float rotationSpeed = 5f;\n    [SerializeField] private float maxLifetime = 10f;\n\n    [SerializeField] private GameObject target;\n    \n    private Rigidbody rb;\n    private float lifetime;\n\n    private void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        \n        if (rb == null)\n        {\n            rb = gameObject.AddComponent<Rigidbody>();\n            rb.useGravity = false;\n        }\n\n        lifetime = 0f;\n    }\n\n    private void FixedUpdate()\n    {\n        // Increment lifetime and destroy if exceeded\n        lifetime += Time.fixedDeltaTime;\n        if (lifetime >= maxLifetime)\n        {\n            Destroy(gameObject);\n            return;\n        }\n\n        // Check if target is valid\n        if (target == null)\n        {\n            Destroy(gameObject);\n            return;\n        }\n\n        // Calculate direction to target\n        Vector3 directionToTarget = (target.transform.position - transform.position).normalized;\n\n        // Smoothly rotate towards target\n        Quaternion targetRotation = Quaternion.LookRotation(directionToTarget);\n        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, rotationSpeed * Time.fixedDeltaTime);\n\n        // Move forward\n        rb.velocity = transform.forward * speed;\n    }\n\n    public void SetTarget(GameObject newTarget)\n    {\n        target = newTarget;\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        // Optional: Add impact logic or damage\n        Destroy(gameObject);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"BreakableWall\",\n  \"components\": [\n    \"Collider\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"health\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"fragmentPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"shatterThreshold\",\n      \"type\": \"float\",\n      \"default\": 50\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when object collides with wall\",\n      \"actions\": [\n        {\n          \"action\": \"reduce wall health based on collision force\"\n        },\n        {\n          \"action\": \"check if health is below shatter threshold\"\n        }\n      ]\n    },\n    {\n      \"name\": \"wall_destruction\",\n      \"trigger\": \"when wall health reaches zero or below\",\n      \"actions\": [\n        {\n          \"action\": \"spawn multiple fragment pieces at wall's current location\"\n        },\n        {\n          \"action\": \"apply random explosive force to fragments\"\n        },\n        {\n          \"action\": \"remove original wall object\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class BreakableWall : MonoBehaviour\n{\n    [SerializeField] private GameObject wallFragmentsPrefab;\n    [SerializeField] private float breakThreshold = 2f;\n    [SerializeField] private AudioClip breakSound;\n\n    private AudioSource audioSource;\n\n    private void Start()\n    {\n        // Ensure audio source is available for sound effects\n        audioSource = GetComponent<AudioSource>() ?? gameObject.AddComponent<AudioSource>();\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        // Calculate impact force\n        float impactForce = collision.relativeVelocity.magnitude;\n\n        // Check if impact is strong enough to break wall\n        if (impactForce >= breakThreshold)\n        {\n            BreakWall(collision.contacts[0].point);\n        }\n    }\n\n    private void BreakWall(Vector3 breakPoint)\n    {\n        // Instantiate wall fragments\n        if (wallFragmentsPrefab != null)\n        {\n            GameObject fragments = Instantiate(wallFragmentsPrefab, transform.position, transform.rotation);\n            \n            // Optional: Apply explosion force to fragments\n            Rigidbody[] fragmentRigidbodies = fragments.GetComponentsInChildren<Rigidbody>();\n            foreach (Rigidbody rb in fragmentRigidbodies)\n            {\n                rb.AddExplosionForce(500f, breakPoint, 5f);\n            }\n        }\n\n        // Play break sound\n        if (breakSound != null && audioSource != null)\n        {\n            audioSource.PlayOneShot(breakSound);\n        }\n\n        // Destroy original wall\n        Destroy(gameObject);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PressurePlate\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"requiredWeight\",\n      \"type\": \"float\",\n      \"default\": 50\n    },\n    {\n      \"name\": \"currentWeight\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isActivated\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_object_weight\",\n      \"trigger\": \"when object enters pressure plate area\",\n      \"actions\": [\n        {\n          \"action\": \"add weight of entering object to current weight\"\n        },\n        {\n          \"action\": \"check if current weight meets required weight threshold\"\n        }\n      ]\n    },\n    {\n      \"name\": \"activate_plate\",\n      \"trigger\": \"when current weight exceeds required weight\",\n      \"actions\": [\n        {\n          \"action\": \"set plate to activated state\"\n        },\n        {\n          \"action\": \"play activation sound effect\"\n        },\n        {\n          \"action\": \"trigger connected mechanism or door\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deactivate_plate\",\n      \"trigger\": \"when no objects remain on pressure plate\",\n      \"actions\": [\n        {\n          \"action\": \"reset current weight to zero\"\n        },\n        {\n          \"action\": \"set plate to deactivated state\"\n        },\n        {\n          \"action\": \"play deactivation sound effect\"\n        },\n        {\n          \"action\": \"reset connected mechanism\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class PressurePlate : MonoBehaviour\n{\n    [SerializeField] private float requiredWeight = 50f;\n    [SerializeField] private float currentWeight = 0f;\n    [SerializeField] private UnityEvent onPressActivated;\n    [SerializeField] private UnityEvent onPressDeactivated;\n\n    [SerializeField] private LayerMask weightableLayers;\n\n    private bool isCurrentlyPressed = false;\n\n    private void OnTriggerStay2D(Collider2D other)\n    {\n        if (((1 << other.gameObject.layer) & weightableLayers) != 0)\n        {\n            Rigidbody2D rb = other.GetComponent<Rigidbody2D>();\n            if (rb != null)\n            {\n                currentWeight += rb.mass;\n\n                if (currentWeight >= requiredWeight && !isCurrentlyPressed)\n                {\n                    isCurrentlyPressed = true;\n                    onPressActivated?.Invoke();\n                }\n            }\n        }\n    }\n\n    private void OnTriggerExit2D(Collider2D other)\n    {\n        if (((1 << other.gameObject.layer) & weightableLayers) != 0)\n        {\n            Rigidbody2D rb = other.GetComponent<Rigidbody2D>();\n            if (rb != null)\n            {\n                currentWeight -= rb.mass;\n\n                if (currentWeight < requiredWeight && isCurrentlyPressed)\n                {\n                    isCurrentlyPressed = false;\n                    onPressDeactivated?.Invoke();\n                }\n            }\n        }\n    }\n\n    private void OnValidate()\n    {\n        requiredWeight = Mathf.Max(0, requiredWeight);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"InteractiveDoor\",\n  \"components\": [\n    \"Collider\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"openDistance\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"isOpen\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"open_on_player_approach\",\n      \"trigger\": \"when player comes within open distance\",\n      \"actions\": [\n        {\n          \"action\": \"play door opening animation\"\n        },\n        {\n          \"action\": \"mark door as open\"\n        },\n        {\n          \"action\": \"disable collision blocking\"\n        },\n        {\n          \"action\": \"emit door opening sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"close_when_player_leaves\",\n      \"trigger\": \"when player moves away beyond open distance\",\n      \"actions\": [\n        {\n          \"action\": \"play door closing animation\"\n        },\n        {\n          \"action\": \"mark door as closed\"\n        },\n        {\n          \"action\": \"enable collision blocking\"\n        },\n        {\n          \"action\": \"emit door closing sound\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class DoorController : MonoBehaviour\n{\n    [SerializeField] private float openDistance = 3f;\n    [SerializeField] private float openSpeed = 2f;\n    [SerializeField] private Vector3 openOffset = new Vector3(0, 0, 2f);\n\n    private Vector3 closedPosition;\n    private Vector3 openPosition;\n    private bool isOpen = false;\n    private Transform playerTransform;\n\n    private void Start()\n    {\n        closedPosition = transform.position;\n        openPosition = closedPosition + openOffset;\n        playerTransform = GameObject.FindGameObjectWithTag(\"Player\").transform;\n    }\n\n    private void Update()\n    {\n        if (playerTransform == null) return;\n\n        float distanceToPlayer = Vector3.Distance(transform.position, playerTransform.position);\n\n        if (distanceToPlayer <= openDistance && !isOpen)\n        {\n            OpenDoor();\n        }\n        else if (distanceToPlayer > openDistance && isOpen)\n        {\n            CloseDoor();\n        }\n    }\n\n    private void OpenDoor()\n    {\n        transform.position = Vector3.Lerp(transform.position, openPosition, openSpeed * Time.deltaTime);\n        \n        if (Vector3.Distance(transform.position, openPosition) < 0.01f)\n        {\n            transform.position = openPosition;\n            isOpen = true;\n        }\n    }\n\n    private void CloseDoor()\n    {\n        transform.position = Vector3.Lerp(transform.position, closedPosition, openSpeed * Time.deltaTime);\n        \n        if (Vector3.Distance(transform.position, closedPosition) < 0.01f)\n        {\n            transform.position = closedPosition;\n            isOpen = false;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DamageShield\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxShieldHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"currentShieldHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"shieldRechargeRate\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"shieldBlockEffectiveness\",\n      \"type\": \"float\",\n      \"default\": 0.75\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"block_incoming_damage\",\n      \"trigger\": \"when projectile or attack contacts shield surface\",\n      \"actions\": [\n        {\n          \"action\": \"reduce shield health based on incoming damage amount\"\n        },\n        {\n          \"action\": \"play shield impact sound effect\"\n        },\n        {\n          \"action\": \"create visual flash or particle effect at impact point\"\n        }\n      ]\n    },\n    {\n      \"name\": \"shield_regeneration\",\n      \"trigger\": \"when shield is not actively blocking damage\",\n      \"actions\": [\n        {\n          \"action\": \"slowly restore shield health over time\"\n        },\n        {\n          \"action\": \"prevent shield health from exceeding maximum value\"\n        }\n      ]\n    },\n    {\n      \"name\": \"shield_depletion\",\n      \"trigger\": \"when shield health reaches zero\",\n      \"actions\": [\n        {\n          \"action\": \"disable shield protection temporarily\"\n        },\n        {\n          \"action\": \"start shield recovery cooldown period\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class ShieldController : MonoBehaviour\n{\n    [SerializeField] private float maxShieldHealth = 100f;\n    [SerializeField] private float shieldRechargeRate = 10f;\n    [SerializeField] private float shieldRechargeDelay = 3f;\n    [SerializeField] private GameObject shieldVisualEffect;\n\n    private float currentShieldHealth;\n    private float lastDamageTime;\n    private bool isShieldActive = true;\n\n    private void Start()\n    {\n        currentShieldHealth = maxShieldHealth;\n        UpdateShieldVisual();\n    }\n\n    private void Update()\n    {\n        HandleShieldRecharge();\n    }\n\n    public void TakeDamage(float damageAmount)\n    {\n        if (!isShieldActive) return;\n\n        currentShieldHealth -= damageAmount;\n        lastDamageTime = Time.time;\n\n        if (currentShieldHealth <= 0)\n        {\n            DisableShield();\n        }\n\n        UpdateShieldVisual();\n    }\n\n    private void HandleShieldRecharge()\n    {\n        if (!isShieldActive && Time.time - lastDamageTime >= shieldRechargeDelay)\n        {\n            currentShieldHealth = Mathf.Min(currentShieldHealth + shieldRechargeRate * Time.deltaTime, maxShieldHealth);\n\n            if (currentShieldHealth >= maxShieldHealth)\n            {\n                EnableShield();\n            }\n\n            UpdateShieldVisual();\n        }\n    }\n\n    private void DisableShield()\n    {\n        isShieldActive = false;\n        if (shieldVisualEffect != null)\n        {\n            shieldVisualEffect.SetActive(false);\n        }\n    }\n\n    private void EnableShield()\n    {\n        isShieldActive = true;\n        if (shieldVisualEffect != null)\n        {\n            shieldVisualEffect.SetActive(true);\n        }\n    }\n\n    private void UpdateShieldVisual()\n    {\n        if (shieldVisualEffect != null)\n        {\n            float shieldPercentage = currentShieldHealth / maxShieldHealth;\n            // Optional: Adjust shield visual based on current health\n            // Example: Change color or transparency\n        }\n    }\n\n    public bool IsShieldActive()\n    {\n        return isShieldActive;\n    }\n\n    public float GetCurrentShieldHealth()\n    {\n        return currentShieldHealth;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SingleTriggerButton\",\n  \"components\": [\n    \"Button\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"hasBeenTriggered\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"triggerEvent\",\n      \"type\": \"UnityEvent\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"button_press_behavior\",\n      \"trigger\": \"when button is clicked and event has not been triggered before\",\n      \"actions\": [\n        {\n          \"action\": \"mark button as triggered\"\n        },\n        {\n          \"action\": \"play button click sound\"\n        },\n        {\n          \"action\": \"invoke the associated trigger event\"\n        },\n        {\n          \"action\": \"disable further button interactions\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_button\",\n      \"trigger\": \"when game state requires button to be available again\",\n      \"actions\": [\n        {\n          \"action\": \"reset button's triggered status\"\n        },\n        {\n          \"action\": \"re-enable button interactions\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class SingleTriggerButton : MonoBehaviour\n{\n    [SerializeField] private UnityEvent onButtonTrigger;\n    [SerializeField] private bool canTrigger = true;\n\n    public void TriggerEvent()\n    {\n        if (canTrigger)\n        {\n            onButtonTrigger?.Invoke();\n            canTrigger = false;\n        }\n    }\n\n    public void ResetTrigger()\n    {\n        canTrigger = true;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PressurePlateDoor\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRadius\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"targetDoor\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"openSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_weight_on_plate\",\n      \"trigger\": \"when something touches the pressure plate surface\",\n      \"actions\": [\n        {\n          \"action\": \"play activation sound effect\"\n        },\n        {\n          \"action\": \"smoothly slide target door open\"\n        },\n        {\n          \"action\": \"change plate color to indicate activated state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_door_when_plate_empty\",\n      \"trigger\": \"when no weight remains on pressure plate\",\n      \"actions\": [\n        {\n          \"action\": \"play deactivation sound effect\"\n        },\n        {\n          \"action\": \"smoothly close target door\"\n        },\n        {\n          \"action\": \"return plate to original color\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class PressurePlate : MonoBehaviour\n{\n    [SerializeField] private Door targetDoor;\n    [SerializeField] private float triggerRadius = 1f;\n    [SerializeField] private LayerMask triggerLayer;\n\n    [Header(\"Visual Feedback\")]\n    [SerializeField] private Renderer plateRenderer;\n    [SerializeField] private Color activeColor = Color.green;\n    [SerializeField] private Color inactiveColor = Color.red;\n\n    private bool isActivated = false;\n\n    private void Start()\n    {\n        // Validate references\n        if (targetDoor == null)\n        {\n            Debug.LogWarning(\"No target door assigned to pressure plate!\");\n        }\n\n        // Set initial color\n        if (plateRenderer != null)\n        {\n            plateRenderer.material.color = inactiveColor;\n        }\n    }\n\n    private void Update()\n    {\n        CheckPressurePlate();\n    }\n\n    private void CheckPressurePlate()\n    {\n        // Check for colliders within trigger radius\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, triggerRadius, triggerLayer);\n\n        bool currentActivation = hitColliders.Length > 0;\n\n        // Only update if state has changed\n        if (currentActivation != isActivated)\n        {\n            isActivated = currentActivation;\n            UpdateDoorState();\n            UpdateVisualFeedback();\n        }\n    }\n\n    private void UpdateDoorState()\n    {\n        if (targetDoor != null)\n        {\n            if (isActivated)\n            {\n                targetDoor.Open();\n            }\n            else\n            {\n                targetDoor.Close();\n            }\n        }\n    }\n\n    private void UpdateVisualFeedback()\n    {\n        if (plateRenderer != null)\n        {\n            plateRenderer.material.color = isActivated ? activeColor : inactiveColor;\n        }\n    }\n\n    // Optional: Visualize trigger radius in editor\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, triggerRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"InteractiveSign\",\n  \"components\": [\n    \"Collider\",\n    \"Text\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"displayMessage\",\n      \"type\": \"string\",\n      \"default\": \"Welcome!\"\n    },\n    {\n      \"name\": \"displayDuration\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"interactionRange\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"show_message\",\n      \"trigger\": \"when player approaches within interaction range\",\n      \"actions\": [\n        {\n          \"action\": \"display text message on screen\"\n        },\n        {\n          \"action\": \"make text visible for specified duration\"\n        },\n        {\n          \"action\": \"fade out message after display time ends\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_message\",\n      \"trigger\": \"when player moves away from interaction range\",\n      \"actions\": [\n        {\n          \"action\": \"immediately clear displayed text\"\n        },\n        {\n          \"action\": \"make text invisible\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class SignDisplay : MonoBehaviour\n{\n    [SerializeField] private Text messageText;\n    [SerializeField] private GameObject signPanel;\n\n    [Header(\"Sign Configuration\")]\n    [SerializeField] private string defaultMessage = \"Welcome!\";\n    [SerializeField] private float displayDuration = 5f;\n\n    private float displayTimer;\n    private bool isDisplaying;\n\n    private void Start()\n    {\n        // Ensure references are set\n        if (messageText == null || signPanel == null)\n        {\n            Debug.LogError(\"Sign display references are missing!\");\n            enabled = false;\n            return;\n        }\n\n        // Hide sign initially\n        HideSign();\n    }\n\n    public void ShowMessage(string message = null)\n    {\n        // Use provided message or default\n        string displayMessage = string.IsNullOrEmpty(message) ? defaultMessage : message;\n        \n        messageText.text = displayMessage;\n        signPanel.SetActive(true);\n        \n        isDisplaying = true;\n        displayTimer = displayDuration;\n    }\n\n    private void Update()\n    {\n        // Auto-hide sign after duration\n        if (isDisplaying)\n        {\n            displayTimer -= Time.deltaTime;\n            \n            if (displayTimer <= 0)\n            {\n                HideSign();\n            }\n        }\n    }\n\n    public void HideSign()\n    {\n        signPanel.SetActive(false);\n        isDisplaying = false;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FallingBoulder\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"triggerDistance\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"fallSpeed\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player_proximity\",\n      \"trigger\": \"when player enters detection radius around boulder\",\n      \"actions\": [\n        {\n          \"action\": \"start falling downward with increasing acceleration\"\n        },\n        {\n          \"action\": \"play rumbling sound effect\"\n        },\n        {\n          \"action\": \"create ground shake visual effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"impact_damage\",\n      \"trigger\": \"when boulder collides with ground or player\",\n      \"actions\": [\n        {\n          \"action\": \"create large impact crater\"\n        },\n        {\n          \"action\": \"deal massive damage to anything underneath\"\n        },\n        {\n          \"action\": \"play loud crushing sound\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class ProximityBoulderTrigger : MonoBehaviour\n{\n    [SerializeField] private float triggerDistance = 5f;\n    [SerializeField] private float fallSpeed = 10f;\n    [SerializeField] private bool isFalling = false;\n\n    [Header(\"References\")]\n    [SerializeField] private Rigidbody boulderRigidbody;\n    [SerializeField] private Transform playerTransform;\n\n    private Vector3 originalPosition;\n\n    private void Start()\n    {\n        // Cache original position for potential reset\n        originalPosition = transform.position;\n\n        // Ensure rigidbody is assigned\n        if (boulderRigidbody == null)\n            boulderRigidbody = GetComponent<Rigidbody>();\n\n        // Disable gravity initially\n        boulderRigidbody.useGravity = false;\n    }\n\n    private void Update()\n    {\n        // Check for player proximity if not already falling\n        if (!isFalling && playerTransform != null)\n        {\n            float distanceToPlayer = Vector3.Distance(transform.position, playerTransform.position);\n\n            if (distanceToPlayer <= triggerDistance)\n            {\n                TriggerBoulderFall();\n            }\n        }\n    }\n\n    private void TriggerBoulderFall()\n    {\n        isFalling = true;\n        boulderRigidbody.useGravity = true;\n        boulderRigidbody.isKinematic = false;\n        boulderRigidbody.AddForce(Vector3.down * fallSpeed, ForceMode.Acceleration);\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        // Optional: Handle boulder landing or player collision\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            // Damage player or trigger game over\n            Debug.Log(\"Boulder hit player!\");\n        }\n    }\n\n    // Optional method to reset boulder\n    public void ResetBoulder()\n    {\n        transform.position = originalPosition;\n        boulderRigidbody.velocity = Vector3.zero;\n        boulderRigidbody.useGravity = false;\n        isFalling = false;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ShieldPickup\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"armorAmount\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"pickupSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"shield_collection\",\n      \"trigger\": \"when player collides with shield pickup\",\n      \"actions\": [\n        {\n          \"action\": \"increase player's total armor value\"\n        },\n        {\n          \"action\": \"play pickup sound effect\"\n        },\n        {\n          \"action\": \"remove shield pickup from game world\"\n        }\n      ]\n    },\n    {\n      \"name\": \"visual_feedback\",\n      \"trigger\": \"immediately after shield is picked up\",\n      \"actions\": [\n        {\n          \"action\": \"display brief armor increase notification\"\n        },\n        {\n          \"action\": \"create small particle effect at pickup location\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class ShieldPickup : MonoBehaviour\n{\n    [SerializeField] private float armorAmount = 25f;\n    [SerializeField] private AudioClip pickupSound;\n    [SerializeField] private GameObject pickupEffectPrefab;\n\n    private void OnTriggerEnter(Collider other)\n    {\n        PlayerHealth playerHealth = other.GetComponent<PlayerHealth>();\n        \n        if (playerHealth != null)\n        {\n            // Add armor to player\n            playerHealth.AddArmor(armorAmount);\n\n            // Play pickup sound\n            if (pickupSound != null)\n            {\n                AudioSource.PlayClipAtPoint(pickupSound, transform.position);\n            }\n\n            // Spawn pickup effect\n            if (pickupEffectPrefab != null)\n            {\n                Instantiate(pickupEffectPrefab, transform.position, Quaternion.identity);\n            }\n\n            // Destroy pickup object\n            Destroy(gameObject);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PowerBow\",\n  \"components\": [\n    \"Weapon\",\n    \"ChargeableItem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"minimumChargeDuration\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"maximumChargeDuration\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"currentChargePower\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"maxPowerMultiplier\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"charge_shot\",\n      \"trigger\": \"when player holds attack button\",\n      \"actions\": [\n        {\n          \"action\": \"gradually increase charge power\"\n        },\n        {\n          \"action\": \"show visual charge indicator\"\n        },\n        {\n          \"action\": \"limit charge power to maximum duration\"\n        }\n      ]\n    },\n    {\n      \"name\": \"release_shot\",\n      \"trigger\": \"when player releases attack button\",\n      \"actions\": [\n        {\n          \"action\": \"calculate shot power based on charge duration\"\n        },\n        {\n          \"action\": \"fire arrow with scaled damage and velocity\"\n        },\n        {\n          \"action\": \"reset charge power to zero\"\n        },\n        {\n          \"action\": \"hide charge indicator\"\n        }\n      ]\n    },\n    {\n      \"name\": \"cancel_charge\",\n      \"trigger\": \"when player interrupts charging\",\n      \"actions\": [\n        {\n          \"action\": \"reset charge power to zero\"\n        },\n        {\n          \"action\": \"hide charge indicator\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class BowController : MonoBehaviour\n{\n    [SerializeField] private GameObject arrowPrefab;\n    [SerializeField] private Transform bowTip;\n    [SerializeField] private float maxChargeDuration = 2f;\n    [SerializeField] private float minArrowForce = 10f;\n    [SerializeField] private float maxArrowForce = 50f;\n\n    private float currentChargeTime;\n    private bool isCharging;\n\n    private void Update()\n    {\n        HandleBowCharging();\n    }\n\n    private void HandleBowCharging()\n    {\n        // Start charging when mouse button is held down\n        if (Input.GetMouseButtonDown(0))\n        {\n            StartCharging();\n        }\n\n        // Continue charging while mouse button is held\n        if (isCharging)\n        {\n            currentChargeTime += Time.deltaTime;\n            currentChargeTime = Mathf.Clamp(currentChargeTime, 0f, maxChargeDuration);\n        }\n\n        // Release arrow when mouse button is released\n        if (Input.GetMouseButtonUp(0) && isCharging)\n        {\n            ShootArrow();\n        }\n    }\n\n    private void StartCharging()\n    {\n        isCharging = true;\n        currentChargeTime = 0f;\n    }\n\n    private void ShootArrow()\n    {\n        if (arrowPrefab == null || bowTip == null)\n        {\n            Debug.LogWarning(\"Arrow prefab or bow tip not assigned!\");\n            return;\n        }\n\n        // Calculate arrow force based on charge duration\n        float chargePercentage = currentChargeTime / maxChargeDuration;\n        float arrowForce = Mathf.Lerp(minArrowForce, maxArrowForce, chargePercentage);\n\n        // Instantiate and shoot arrow\n        GameObject arrow = Instantiate(arrowPrefab, bowTip.position, bowTip.rotation);\n        Rigidbody arrowRb = arrow.GetComponent<Rigidbody>();\n\n        if (arrowRb != null)\n        {\n            arrowRb.AddForce(bowTip.forward * arrowForce, ForceMode.Impulse);\n        }\n\n        // Reset charging state\n        isCharging = false;\n        currentChargeTime = 0f;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ParachuteController\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"glideSpeed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"horizontalControlFactor\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"verticalDescendRate\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"deploy_parachute\",\n      \"trigger\": \"player jumps from high elevation\",\n      \"actions\": [\n        {\n          \"action\": \"open parachute visual effect\"\n        },\n        {\n          \"action\": \"reduce falling speed gradually\"\n        },\n        {\n          \"action\": \"enable horizontal movement control\"\n        }\n      ]\n    },\n    {\n      \"name\": \"control_gliding\",\n      \"trigger\": \"parachute is deployed\",\n      \"actions\": [\n        {\n          \"action\": \"drift horizontally based on player input\"\n        },\n        {\n          \"action\": \"maintain steady controlled descent\"\n        },\n        {\n          \"action\": \"adjust angle to control horizontal distance\"\n        }\n      ]\n    },\n    {\n      \"name\": \"land_safely\",\n      \"trigger\": \"approaching ground surface\",\n      \"actions\": [\n        {\n          \"action\": \"slow descent rate\"\n        },\n        {\n          \"action\": \"prepare for soft landing\"\n        },\n        {\n          \"action\": \"disable parachute physics\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class ParachuteController : MonoBehaviour\n{\n    [SerializeField] private float glideSpeed = 5f;\n    [SerializeField] private float descendSpeed = 2f;\n    [SerializeField] private float openHeight = 50f;\n    [SerializeField] private float minGlideAngle = 15f;\n    [SerializeField] private float maxGlideAngle = 45f;\n\n    private Rigidbody rb;\n    private bool isParachuteDeployed = false;\n\n    private void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        \n        // Disable gravity initially\n        if (rb != null)\n        {\n            rb.useGravity = false;\n        }\n    }\n\n    private void Update()\n    {\n        CheckParachuteDeployment();\n    }\n\n    private void FixedUpdate()\n    {\n        if (isParachuteDeployed)\n        {\n            ApplyGliding();\n        }\n    }\n\n    private void CheckParachuteDeployment()\n    {\n        // Deploy parachute at specific height or when player triggers\n        if (!isParachuteDeployed && transform.position.y <= openHeight)\n        {\n            DeployParachute();\n        }\n    }\n\n    private void DeployParachute()\n    {\n        isParachuteDeployed = true;\n        \n        if (rb != null)\n        {\n            rb.useGravity = true;\n        }\n    }\n\n    private void ApplyGliding()\n    {\n        // Calculate glide direction based on player input or current orientation\n        Vector3 glideDirection = transform.forward;\n        \n        // Apply horizontal movement\n        rb.velocity = glideDirection * glideSpeed;\n        \n        // Controlled descent\n        Vector3 verticalVelocity = Vector3.down * descendSpeed;\n        rb.velocity += verticalVelocity;\n\n        // Optional: Limit descent angle\n        float currentAngle = Vector3.Angle(Vector3.down, rb.velocity);\n        currentAngle = Mathf.Clamp(currentAngle, minGlideAngle, maxGlideAngle);\n    }\n\n    public void CutParachute()\n    {\n        isParachuteDeployed = false;\n        \n        if (rb != null)\n        {\n            rb.useGravity = true;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LedgeClimbController\",\n  \"components\": [\n    \"CharacterController\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"ledgeDetectionRange\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"climbHeight\",\n      \"type\": \"float\",\n      \"default\": 1.2\n    },\n    {\n      \"name\": \"climbSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_ledge\",\n      \"trigger\": \"when character is near a ledge and jumping or falling\",\n      \"actions\": [\n        {\n          \"action\": \"check if ledge is within detection range\"\n        },\n        {\n          \"action\": \"align character to ledge edge\"\n        },\n        {\n          \"action\": \"transition to ledge grab animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"climb_ledge\",\n      \"trigger\": \"when character is in ledge grab state\",\n      \"actions\": [\n        {\n          \"action\": \"smoothly pull character up to ledge height\"\n        },\n        {\n          \"action\": \"play climbing animation\"\n        },\n        {\n          \"action\": \"move character vertically to top of ledge\"\n        },\n        {\n          \"action\": \"set character to standing state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class LedgeClimbController : MonoBehaviour\n{\n    [Header(\"Ledge Grab Settings\")]\n    [SerializeField] private float grabDetectionDistance = 0.5f;\n    [SerializeField] private float climbUpSpeed = 3f;\n    [SerializeField] private LayerMask ledgeMask;\n\n    [Header(\"Player References\")]\n    [SerializeField] private Transform playerTransform;\n    [SerializeField] private Rigidbody2D playerRigidbody;\n    [SerializeField] private Animator playerAnimator;\n\n    private bool isGrabbingLedge = false;\n    private Vector2 ledgePosition;\n    private Vector2 climbDirection;\n\n    private void Update()\n    {\n        if (!isGrabbingLedge)\n        {\n            CheckForLedgeGrab();\n        }\n        else\n        {\n            HandleLedgeClimb();\n        }\n    }\n\n    private void CheckForLedgeGrab()\n    {\n        // Raycast to detect ledges in front of the player\n        RaycastHit2D ledgeHit = Physics2D.Raycast(\n            playerTransform.position, \n            playerTransform.right, \n            grabDetectionDistance, \n            ledgeMask\n        );\n\n        if (ledgeHit.collider != null)\n        {\n            // Check if player is falling and near a ledge\n            if (playerRigidbody.velocity.y < 0)\n            {\n                GrabLedge(ledgeHit.point);\n            }\n        }\n    }\n\n    private void GrabLedge(Vector2 hitPoint)\n    {\n        isGrabbingLedge = true;\n        ledgePosition = hitPoint;\n\n        // Disable player physics and set grab animation\n        playerRigidbody.isKinematic = true;\n        playerRigidbody.velocity = Vector2.zero;\n        playerAnimator.SetBool(\"IsGrabbingLedge\", true);\n    }\n\n    private void HandleLedgeClimb()\n    {\n        // Check for climb input (e.g., jump button)\n        if (Input.GetButtonDown(\"Jump\"))\n        {\n            // Determine climb direction based on player orientation\n            climbDirection = playerTransform.up;\n\n            // Move player up and over the ledge\n            playerTransform.position = Vector2.MoveTowards(\n                playerTransform.position, \n                ledgePosition + climbDirection, \n                climbUpSpeed * Time.deltaTime\n            );\n\n            // Reset ledge grab state\n            if (Vector2.Distance(playerTransform.position, ledgePosition) < 0.1f)\n            {\n                ReleaseLedge();\n            }\n        }\n    }\n\n    private void ReleaseLedge()\n    {\n        isGrabbingLedge = false;\n        playerRigidbody.isKinematic = false;\n        playerAnimator.SetBool(\"IsGrabbingLedge\", false);\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        // Visualize ledge grab detection in scene view\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawRay(playerTransform.position, playerTransform.right * grabDetectionDistance);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Helicopter\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxAltitude\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"minAltitude\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"verticalSpeed\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"stabilizationSmoothness\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"altitude_stabilization\",\n      \"trigger\": \"helicopter is airborne\",\n      \"actions\": [\n        {\n          \"action\": \"maintain current altitude smoothly\"\n        },\n        {\n          \"action\": \"prevent drifting above maximum altitude\"\n        },\n        {\n          \"action\": \"prevent falling below minimum safe altitude\"\n        }\n      ]\n    },\n    {\n      \"name\": \"vertical_movement\",\n      \"trigger\": \"pilot controls vertical thrust\",\n      \"actions\": [\n        {\n          \"action\": \"increase altitude when upward thrust is applied\"\n        },\n        {\n          \"action\": \"decrease altitude when downward thrust is applied\"\n        },\n        {\n          \"action\": \"limit vertical movement speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"emergency_landing\",\n      \"trigger\": \"critical system failure detected\",\n      \"actions\": [\n        {\n          \"action\": \"gradually descend to ground level\"\n        },\n        {\n          \"action\": \"activate landing stabilization\"\n        },\n        {\n          \"action\": \"disable flight controls\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class HelicopterController : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float horizontalSpeed = 5f;\n    [SerializeField] private float verticalSpeed = 3f;\n    [SerializeField] private float maxAltitude = 100f;\n    [SerializeField] private float minAltitude = 0f;\n\n    [Header(\"Stabilization\")]\n    [SerializeField] private float stabilizationSmoothing = 2f;\n\n    [Header(\"References\")]\n    [SerializeField] private Rigidbody helicopterRigidbody;\n\n    private Vector3 targetPosition;\n\n    private void Start()\n    {\n        // Ensure Rigidbody is assigned\n        if (helicopterRigidbody == null)\n        {\n            helicopterRigidbody = GetComponent<Rigidbody>();\n        }\n\n        // Initialize target position to current position\n        targetPosition = transform.position;\n    }\n\n    private void Update()\n    {\n        HandleHorizontalMovement();\n        HandleVerticalMovement();\n    }\n\n    private void FixedUpdate()\n    {\n        ApplyMovement();\n    }\n\n    private void HandleHorizontalMovement()\n    {\n        float horizontalInput = Input.GetAxis(\"Horizontal\");\n        float verticalInput = Input.GetAxis(\"Vertical\");\n\n        // Calculate target position based on input\n        Vector3 moveDirection = transform.forward * verticalInput + transform.right * horizontalInput;\n        targetPosition += moveDirection * horizontalSpeed * Time.deltaTime;\n    }\n\n    private void HandleVerticalMovement()\n    {\n        float altitudeInput = 0f;\n\n        // Altitude control with keyboard\n        if (Input.GetKey(KeyCode.Q))\n        {\n            altitudeInput = 1f;\n        }\n        else if (Input.GetKey(KeyCode.E))\n        {\n            altitudeInput = -1f;\n        }\n\n        // Clamp altitude\n        targetPosition.y = Mathf.Clamp(\n            targetPosition.y + altitudeInput * verticalSpeed * Time.deltaTime, \n            minAltitude, \n            maxAltitude\n        );\n    }\n\n    private void ApplyMovement()\n    {\n        if (helicopterRigidbody != null)\n        {\n            // Smoothly interpolate to target position\n            Vector3 newPosition = Vector3.Lerp(\n                helicopterRigidbody.position, \n                targetPosition, \n                stabilizationSmoothing * Time.fixedDeltaTime\n            );\n\n            helicopterRigidbody.MovePosition(newPosition);\n        }\n    }\n\n    // Optional: Add rotation stabilization\n    private void StabilizeRotation()\n    {\n        // Gradually return to level rotation\n        Quaternion targetRotation = Quaternion.Euler(0, transform.rotation.eulerAngles.y, 0);\n        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, Time.deltaTime * stabilizationSmoothing);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LaserWeapon\",\n  \"components\": [\n    \"LineRenderer\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"beamDamage\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"beamRange\",\n      \"type\": \"float\",\n      \"default\": 50.0\n    },\n    {\n      \"name\": \"beamWidth\",\n      \"type\": \"float\",\n      \"default\": 0.2\n    },\n    {\n      \"name\": \"heatBuildup\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"maxHeat\",\n      \"type\": \"float\",\n      \"default\": 100\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"continuous_beam_firing\",\n      \"trigger\": \"weapon trigger is held down\",\n      \"actions\": [\n        {\n          \"action\": \"create continuous laser beam visual effect\"\n        },\n        {\n          \"action\": \"apply damage to target in beam path\"\n        },\n        {\n          \"action\": \"increase weapon heat gradually\"\n        },\n        {\n          \"action\": \"play sustained laser sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"beam_overheat_protection\",\n      \"trigger\": \"weapon heat reaches maximum threshold\",\n      \"actions\": [\n        {\n          \"action\": \"stop firing laser\"\n        },\n        {\n          \"action\": \"disable weapon temporarily\"\n        },\n        {\n          \"action\": \"start weapon cooldown process\"\n        }\n      ]\n    },\n    {\n      \"name\": \"beam_cooldown\",\n      \"trigger\": \"weapon is overheated\",\n      \"actions\": [\n        {\n          \"action\": \"gradually reduce weapon heat\"\n        },\n        {\n          \"action\": \"re-enable weapon when heat is low\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class LaserWeapon : MonoBehaviour\n{\n    [SerializeField] private LineRenderer laserLineRenderer;\n    [SerializeField] private Transform firePoint;\n    [SerializeField] private LayerMask targetLayer;\n    [SerializeField] private float laserRange = 100f;\n    [SerializeField] private float damagePerSecond = 10f;\n    [SerializeField] private float laserWidth = 0.1f;\n    [SerializeField] private Color laserColor = Color.red;\n\n    private bool isLaserActive = false;\n    private RaycastHit hitInfo;\n\n    private void Start()\n    {\n        // Initialize line renderer settings\n        if (laserLineRenderer == null)\n            laserLineRenderer = GetComponent<LineRenderer>();\n\n        ConfigureLaserRenderer();\n    }\n\n    private void ConfigureLaserRenderer()\n    {\n        laserLineRenderer.startWidth = laserWidth;\n        laserLineRenderer.endWidth = laserWidth;\n        laserLineRenderer.startColor = laserColor;\n        laserLineRenderer.endColor = laserColor;\n        laserLineRenderer.positionCount = 2;\n    }\n\n    private void Update()\n    {\n        // Check for laser fire input\n        if (Input.GetButton(\"Fire1\"))\n        {\n            FireLaser();\n        }\n        else\n        {\n            StopLaser();\n        }\n    }\n\n    private void FireLaser()\n    {\n        isLaserActive = true;\n        \n        // Perform raycast to detect targets\n        if (Physics.Raycast(firePoint.position, firePoint.forward, out hitInfo, laserRange, targetLayer))\n        {\n            // Update line renderer to show laser beam\n            laserLineRenderer.SetPosition(0, firePoint.position);\n            laserLineRenderer.SetPosition(1, hitInfo.point);\n\n            // Apply damage to hit target\n            IDamageable damageable = hitInfo.collider.GetComponent<IDamageable>();\n            if (damageable != null)\n            {\n                damageable.TakeDamage(damagePerSecond * Time.deltaTime);\n            }\n        }\n        else\n        {\n            // No target hit, draw full-length laser\n            laserLineRenderer.SetPosition(0, firePoint.position);\n            laserLineRenderer.SetPosition(1, firePoint.position + firePoint.forward * laserRange);\n        }\n\n        // Enable line renderer\n        laserLineRenderer.enabled = true;\n    }\n\n    private void StopLaser()\n    {\n        isLaserActive = false;\n        laserLineRenderer.enabled = false;\n    }\n\n    // Optional: Interface for damage handling\n    public interface IDamageable\n    {\n        void TakeDamage(float damage);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SequenceMemoryGame\",\n  \"components\": [\n    \"AudioSource\",\n    \"UI Text\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"sequenceLength\",\n      \"type\": \"int\",\n      \"default\": 4\n    },\n    {\n      \"name\": \"currentLevel\",\n      \"type\": \"int\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"playerSequence\",\n      \"type\": \"list\",\n      \"default\": []\n    },\n    {\n      \"name\": \"correctSequence\",\n      \"type\": \"list\",\n      \"default\": []\n    },\n    {\n      \"name\": \"gameSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"playerScore\",\n      \"type\": \"int\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"generate_sequence\",\n      \"trigger\": \"start of game or after successful player sequence\",\n      \"actions\": [\n        {\n          \"action\": \"create a random sequence of colored buttons\"\n        },\n        {\n          \"action\": \"display sequence to player with visual and audio cues\"\n        },\n        {\n          \"action\": \"clear player's current input sequence\"\n        }\n      ]\n    },\n    {\n      \"name\": \"player_input_sequence\",\n      \"trigger\": \"player clicks colored buttons\",\n      \"actions\": [\n        {\n          \"action\": \"record player's button press order\"\n        },\n        {\n          \"action\": \"compare player sequence against correct sequence\"\n        }\n      ]\n    },\n    {\n      \"name\": \"validate_sequence\",\n      \"trigger\": \"player completes input sequence\",\n      \"actions\": [\n        {\n          \"action\": \"check if player sequence matches correct sequence\"\n        },\n        {\n          \"action\": \"if correct, increase game level and score\"\n        },\n        {\n          \"action\": \"if incorrect, trigger game over sequence\"\n        }\n      ]\n    },\n    {\n      \"name\": \"increase_difficulty\",\n      \"trigger\": \"player successfully completes current level\",\n      \"actions\": [\n        {\n          \"action\": \"increase sequence length\"\n        },\n        {\n          \"action\": \"increase game playback speed\"\n        },\n        {\n          \"action\": \"add more complex button patterns\"\n        }\n      ]\n    },\n    {\n      \"name\": \"game_over\",\n      \"trigger\": \"player makes incorrect sequence selection\",\n      \"actions\": [\n        {\n          \"action\": \"display final score\"\n        },\n        {\n          \"action\": \"play failure sound effect\"\n        },\n        {\n          \"action\": \"offer option to restart game\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class SequenceMemoryGame : MonoBehaviour\n{\n    [Header(\"Game Configuration\")]\n    [SerializeField] private int sequenceLength = 4;\n    [SerializeField] private float showSequenceDuration = 1f;\n    [SerializeField] private float buttonHighlightDuration = 0.5f;\n\n    [Header(\"UI References\")]\n    [SerializeField] private Button[] gameButtons;\n    [SerializeField] private Text scoreText;\n    [SerializeField] private Text instructionText;\n\n    private List<int> correctSequence = new List<int>();\n    private List<int> playerSequence = new List<int>();\n    private int currentScore = 0;\n    private bool isShowingSequence = false;\n    private bool isPlayerTurn = false;\n\n    private void Start()\n    {\n        InitializeGame();\n        SetupButtonListeners();\n    }\n\n    private void InitializeGame()\n    {\n        currentScore = 0;\n        UpdateScoreDisplay();\n        StartNewRound();\n    }\n\n    private void SetupButtonListeners()\n    {\n        for (int i = 0; i < gameButtons.Length; i++)\n        {\n            int buttonIndex = i;\n            gameButtons[i].onClick.AddListener(() => OnButtonPressed(buttonIndex));\n        }\n    }\n\n    private void StartNewRound()\n    {\n        correctSequence.Clear();\n        playerSequence.Clear();\n        GenerateRandomSequence();\n        StartCoroutine(ShowSequenceToPlayer());\n    }\n\n    private void GenerateRandomSequence()\n    {\n        for (int i = 0; i < sequenceLength; i++)\n        {\n            int randomButton = Random.Range(0, gameButtons.Length);\n            correctSequence.Add(randomButton);\n        }\n    }\n\n    private IEnumerator ShowSequenceToPlayer()\n    {\n        isShowingSequence = true;\n        instructionText.text = \"Watch the sequence!\";\n\n        foreach (int buttonIndex in correctSequence)\n        {\n            HighlightButton(buttonIndex);\n            yield return new WaitForSeconds(showSequenceDuration);\n        }\n\n        isShowingSequence = false;\n        isPlayerTurn = true;\n        instructionText.text = \"Repeat the sequence!\";\n    }\n\n    private void HighlightButton(int buttonIndex)\n    {\n        StartCoroutine(HighlightButtonCoroutine(buttonIndex));\n    }\n\n    private IEnumerator HighlightButtonCoroutine(int buttonIndex)\n    {\n        gameButtons[buttonIndex].image.color = Color.yellow;\n        yield return new WaitForSeconds(buttonHighlightDuration);\n        gameButtons[buttonIndex].image.color = Color.white;\n    }\n\n    private void OnButtonPressed(int buttonIndex)\n    {\n        if (!isPlayerTurn || isShowingSequence)\n            return;\n\n        playerSequence.Add(buttonIndex);\n        HighlightButton(buttonIndex);\n\n        if (!IsSequenceCorrectSoFar())\n        {\n            GameOver();\n            return;\n        }\n\n        if (playerSequence.Count == correctSequence.Count)\n        {\n            CompleteRound();\n        }\n    }\n\n    private bool IsSequenceCorrectSoFar()\n    {\n        for (int i = 0; i < playerSequence.Count; i++)\n        {\n            if (playerSequence[i] != correctSequence[i])\n                return false;\n        }\n        return true;\n    }\n\n    private void CompleteRound()\n    {\n        currentScore++;\n        UpdateScoreDisplay();\n        isPlayerTurn = false;\n        StartCoroutine(StartNextRoundDelay());\n    }\n\n    private IEnumerator StartNextRoundDelay()\n    {\n        instructionText.text = \"Correct!\";\n        yield return new WaitForSeconds(1f);\n        StartNewRound();\n    }\n\n    private void GameOver()\n    {\n        instructionText.text = \"Game Over! Try Again.\";\n        isPlayerTurn = false;\n        Invoke(\"InitializeGame\", 2f);\n    }\n\n    private void UpdateScoreDisplay()\n    {\n        if (scoreText != null)\n            scoreText.text = \"Score: \" + currentScore;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PlayerJumpController\",\n  \"components\": [\n    \"Rigidbody\",\n    \"GroundCheck\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"jumpForce\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"maxJumpDuration\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"isGrounded\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"ground_check\",\n      \"trigger\": \"when player touches ground surface\",\n      \"actions\": [\n        {\n          \"action\": \"mark player as grounded\"\n        },\n        {\n          \"action\": \"reset jump state\"\n        }\n      ]\n    },\n    {\n      \"name\": \"jump_start\",\n      \"trigger\": \"when jump button is first pressed and player is grounded\",\n      \"actions\": [\n        {\n          \"action\": \"apply initial upward force\"\n        },\n        {\n          \"action\": \"mark player as not grounded\"\n        },\n        {\n          \"action\": \"start jump duration timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"variable_jump_height\",\n      \"trigger\": \"while jump button is held down during jump\",\n      \"actions\": [\n        {\n          \"action\": \"continue applying upward force\"\n        },\n        {\n          \"action\": \"increase jump height based on button press duration\"\n        },\n        {\n          \"action\": \"stop applying force if max jump duration reached\"\n        }\n      ]\n    },\n    {\n      \"name\": \"jump_end\",\n      \"trigger\": \"when jump button is released or max jump duration reached\",\n      \"actions\": [\n        {\n          \"action\": \"stop applying jump force\"\n        },\n        {\n          \"action\": \"begin fall trajectory\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class PlayerJump : MonoBehaviour\n{\n    [SerializeField] private float jumpForce = 5f;\n    [SerializeField] private float variableJumpMultiplier = 0.5f;\n    [SerializeField] private float maxJumpTime = 0.5f;\n    [SerializeField] private LayerMask groundLayer;\n    [SerializeField] private float groundCheckDistance = 0.1f;\n\n    private Rigidbody2D rb;\n    private bool isGrounded;\n    private bool isJumping;\n    private float jumpTimeCounter;\n\n    private void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        \n        if (rb == null)\n        {\n            Debug.LogError(\"Rigidbody2D component not found on player!\");\n        }\n    }\n\n    private void Update()\n    {\n        CheckGrounded();\n        HandleJumpInput();\n    }\n\n    private void CheckGrounded()\n    {\n        isGrounded = Physics2D.Raycast(transform.position, Vector2.down, groundCheckDistance, groundLayer);\n    }\n\n    private void HandleJumpInput()\n    {\n        // Initial jump press\n        if (Input.GetButtonDown(\"Jump\") && isGrounded)\n        {\n            StartJump();\n        }\n\n        // Variable height jump\n        if (Input.GetButton(\"Jump\") && isJumping)\n        {\n            if (jumpTimeCounter > 0)\n            {\n                rb.velocity = new Vector2(rb.velocity.x, jumpForce * variableJumpMultiplier);\n                jumpTimeCounter -= Time.deltaTime;\n            }\n            else\n            {\n                isJumping = false;\n            }\n        }\n\n        // Jump release\n        if (Input.GetButtonUp(\"Jump\"))\n        {\n            isJumping = false;\n            jumpTimeCounter = 0;\n        }\n    }\n\n    private void StartJump()\n    {\n        isJumping = true;\n        jumpTimeCounter = maxJumpTime;\n        rb.velocity = new Vector2(rb.velocity.x, jumpForce);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ShopManager\",\n  \"components\": [\n    \"UI Canvas\",\n    \"Item Database\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"availableItems\",\n      \"type\": \"list\",\n      \"default\": []\n    },\n    {\n      \"name\": \"playerCurrency\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"selectedItem\",\n      \"type\": \"object\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"load_shop_inventory\",\n      \"trigger\": \"when shop scene is first loaded\",\n      \"actions\": [\n        {\n          \"action\": \"retrieve all purchasable items from game database\"\n        },\n        {\n          \"action\": \"populate visual display with item details\"\n        },\n        {\n          \"action\": \"show item prices and descriptions\"\n        }\n      ]\n    },\n    {\n      \"name\": \"select_item\",\n      \"trigger\": \"when player clicks on an item in shop display\",\n      \"actions\": [\n        {\n          \"action\": \"highlight selected item\"\n        },\n        {\n          \"action\": \"show detailed item information\"\n        },\n        {\n          \"action\": \"enable purchase button\"\n        }\n      ]\n    },\n    {\n      \"name\": \"purchase_item\",\n      \"trigger\": \"when player confirms item purchase\",\n      \"actions\": [\n        {\n          \"action\": \"check if player has enough currency\"\n        },\n        {\n          \"action\": \"deduct item cost from player's currency\"\n        },\n        {\n          \"action\": \"add purchased item to player's inventory\"\n        },\n        {\n          \"action\": \"display purchase confirmation message\"\n        }\n      ]\n    },\n    {\n      \"name\": \"refresh_shop_display\",\n      \"trigger\": \"after any purchase or inventory change\",\n      \"actions\": [\n        {\n          \"action\": \"update available items list\"\n        },\n        {\n          \"action\": \"recalculate player's remaining currency\"\n        },\n        {\n          \"action\": \"redraw shop inventory display\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class ShopManager : MonoBehaviour\n{\n    [SerializeField] private List<ShopItem> availableItems;\n    [SerializeField] private Transform itemContainer;\n    [SerializeField] private GameObject itemPrefab;\n\n    [SerializeField] private int playerCurrency = 100;\n    [SerializeField] private TMPro.TextMeshProUGUI currencyText;\n\n    private void Start()\n    {\n        InitializeShop();\n        UpdateCurrencyDisplay();\n    }\n\n    private void InitializeShop()\n    {\n        if (itemContainer == null || itemPrefab == null) return;\n\n        foreach (ShopItem item in availableItems)\n        {\n            GameObject itemObject = Instantiate(itemPrefab, itemContainer);\n            ShopItemUI itemUI = itemObject.GetComponent<ShopItemUI>();\n            \n            if (itemUI != null)\n            {\n                itemUI.SetupItem(item, TryPurchaseItem);\n            }\n        }\n    }\n\n    private bool TryPurchaseItem(ShopItem item)\n    {\n        if (playerCurrency >= item.Price)\n        {\n            playerCurrency -= item.Price;\n            UpdateCurrencyDisplay();\n            // Add item to player inventory\n            return true;\n        }\n        return false;\n    }\n\n    private void UpdateCurrencyDisplay()\n    {\n        if (currencyText != null)\n        {\n            currencyText.text = $\"Currency: {playerCurrency}\";\n        }\n    }\n}\n\n[System.Serializable]\npublic class ShopItem\n{\n    public string ItemName;\n    public int Price;\n    public Sprite ItemIcon;\n}\n\npublic class ShopItemUI : MonoBehaviour\n{\n    [SerializeField] private TMPro.TextMeshProUGUI nameText;\n    [SerializeField] private TMPro.TextMeshProUGUI priceText;\n    [SerializeField] private UnityEngine.UI.Image iconImage;\n    [SerializeField] private UnityEngine.UI.Button purchaseButton;\n\n    private ShopItem currentItem;\n    private System.Func<ShopItem, bool> purchaseCallback;\n\n    public void SetupItem(ShopItem item, System.Func<ShopItem, bool> onPurchase)\n    {\n        currentItem = item;\n        purchaseCallback = onPurchase;\n\n        if (nameText != null) nameText.text = item.ItemName;\n        if (priceText != null) priceText.text = $\"${item.Price}\";\n        if (iconImage != null) iconImage.sprite = item.ItemIcon;\n\n        if (purchaseButton != null)\n        {\n            purchaseButton.onClick.AddListener(AttemptPurchase);\n        }\n    }\n\n    private void AttemptPurchase()\n    {\n        if (purchaseCallback != null && purchaseCallback(currentItem))\n        {\n            // Purchase successful\n            purchaseButton.interactable = false;\n        }\n        else\n        {\n            // Purchase failed (not enough currency)\n            // Could show an error message\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"EnemyChaser\",\n  \"components\": [\n    \"NavMeshAgent\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRadius\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"walkSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"chaseSpeed\",\n      \"type\": \"float\",\n      \"default\": 4.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player\",\n      \"trigger\": \"when player enters detection radius\",\n      \"actions\": [\n        {\n          \"action\": \"start moving toward player\"\n        },\n        {\n          \"action\": \"increase movement speed to chase speed\"\n        },\n        {\n          \"action\": \"play chase animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"lose_player\",\n      \"trigger\": \"when player moves outside detection radius\",\n      \"actions\": [\n        {\n          \"action\": \"stop moving\"\n        },\n        {\n          \"action\": \"return to default walking speed\"\n        },\n        {\n          \"action\": \"play idle animation\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class EnemyChaser : MonoBehaviour\n{\n    [SerializeField] private float moveSpeed = 3f;\n    [SerializeField] private float detectionRadius = 5f;\n    [SerializeField] private float stopChaseDistance = 0.5f;\n\n    [SerializeField] private LayerMask playerLayer;\n\n    private Transform player;\n    private bool isChasing = false;\n\n    private void Start()\n    {\n        // Find the player in the scene\n        player = GameObject.FindGameObjectWithTag(\"Player\")?.transform;\n    }\n\n    private void Update()\n    {\n        if (player == null) return;\n\n        // Check if player is within detection radius\n        float distanceToPlayer = Vector3.Distance(transform.position, player.position);\n\n        if (distanceToPlayer <= detectionRadius)\n        {\n            isChasing = true;\n        }\n\n        if (isChasing && distanceToPlayer > stopChaseDistance)\n        {\n            ChasePlayer();\n        }\n        else\n        {\n            isChasing = false;\n        }\n    }\n\n    private void ChasePlayer()\n    {\n        // Calculate direction to player\n        Vector3 directionToPlayer = (player.position - transform.position).normalized;\n\n        // Move towards player\n        transform.position += directionToPlayer * moveSpeed * Time.deltaTime;\n\n        // Optional: Rotate to face player\n        transform.rotation = Quaternion.LookRotation(directionToPlayer);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ElectrifiedFloor\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"damageAmount\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"pulseCooldown\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"pulse_electricity\",\n      \"trigger\": \"when periodic timer reaches pulse interval\",\n      \"actions\": [\n        {\n          \"action\": \"activate electrical visual effect\"\n        },\n        {\n          \"action\": \"play electrical zapping sound\"\n        },\n        {\n          \"action\": \"create sparking particle effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"damage_contact\",\n      \"trigger\": \"when living entity touches floor surface\",\n      \"actions\": [\n        {\n          \"action\": \"apply electrical damage to contacted entity\"\n        },\n        {\n          \"action\": \"briefly stun contacted entity\"\n        },\n        {\n          \"action\": \"push contacted entity backwards\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deactivate_floor\",\n      \"trigger\": \"when floor receives disable signal\",\n      \"actions\": [\n        {\n          \"action\": \"stop electrical visual effects\"\n        },\n        {\n          \"action\": \"stop electrical sound\"\n        },\n        {\n          \"action\": \"prevent damage application\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class ElectrifiedFloor : MonoBehaviour\n{\n    [SerializeField] private float pulseDuration = 2f;\n    [SerializeField] private float damageAmount = 10f;\n    [SerializeField] private Color activeColor = Color.yellow;\n    [SerializeField] private Color inactiveColor = Color.gray;\n\n    private Renderer floorRenderer;\n    private float pulseTimer;\n    private bool isElectrified;\n\n    private void Start()\n    {\n        floorRenderer = GetComponent<Renderer>();\n        if (floorRenderer == null)\n        {\n            Debug.LogError(\"ElectrifiedFloor requires a Renderer component\");\n            enabled = false;\n        }\n    }\n\n    private void Update()\n    {\n        pulseTimer += Time.deltaTime;\n\n        if (pulseTimer >= pulseDuration)\n        {\n            ToggleElectrification();\n            pulseTimer = 0f;\n        }\n    }\n\n    private void ToggleElectrification()\n    {\n        isElectrified = !isElectrified;\n        floorRenderer.material.color = isElectrified ? activeColor : inactiveColor;\n    }\n\n    private void OnTriggerStay(Collider other)\n    {\n        if (isElectrified)\n        {\n            Health playerHealth = other.GetComponent<Health>();\n            if (playerHealth != null)\n            {\n                playerHealth.TakeDamage(damageAmount);\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ShieldBearerEnemy\",\n  \"components\": [\n    \"Health\",\n    \"Movement\",\n    \"Combat\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"shieldRadius\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"shieldStrength\",\n      \"type\": \"float\",\n      \"default\": 25.0\n    },\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"scan_for_allies\",\n      \"trigger\": \"when enemy allies are nearby in detection range\",\n      \"actions\": [\n        {\n          \"action\": \"identify nearby allies that need protection\"\n        },\n        {\n          \"action\": \"activate protective shield around closest ally\"\n        }\n      ]\n    },\n    {\n      \"name\": \"apply_shield_protection\",\n      \"trigger\": \"when ally health is below half maximum\",\n      \"actions\": [\n        {\n          \"action\": \"create damage reduction barrier around ally\"\n        },\n        {\n          \"action\": \"increase ally's defensive capabilities\"\n        }\n      ]\n    },\n    {\n      \"name\": \"shield_positioning\",\n      \"trigger\": \"when in combat with enemy group\",\n      \"actions\": [\n        {\n          \"action\": \"move to central position among allies\"\n        },\n        {\n          \"action\": \"maintain defensive stance\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class EnemyShieldSupport : MonoBehaviour\n{\n    [SerializeField] private float shieldRadius = 5f;\n    [SerializeField] private float shieldStrength = 20f;\n    [SerializeField] private float shieldCooldown = 2f;\n\n    [SerializeField] private LayerMask allyLayerMask;\n\n    private float lastShieldTime;\n    private List<GameObject> shieldedAllies = new List<GameObject>();\n\n    private void Update()\n    {\n        if (Time.time - lastShieldTime >= shieldCooldown)\n        {\n            ApplyShieldToNearbyAllies();\n            lastShieldTime = Time.time;\n        }\n    }\n\n    private void ApplyShieldToNearbyAllies()\n    {\n        Collider[] nearbyAllies = Physics.OverlapSphere(transform.position, shieldRadius, allyLayerMask);\n\n        foreach (Collider ally in nearbyAllies)\n        {\n            HealthComponent healthComponent = ally.GetComponent<HealthComponent>();\n            if (healthComponent != null)\n            {\n                healthComponent.AddTemporaryShield(shieldStrength);\n                shieldedAllies.Add(ally.gameObject);\n            }\n        }\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, shieldRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CrumblingPlatform\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"fallDelay\",\n      \"type\": \"float\",\n      \"default\": 1.5\n    },\n    {\n      \"name\": \"fallSpeed\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"isSteppedOn\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player_step\",\n      \"trigger\": \"when player touches platform surface\",\n      \"actions\": [\n        {\n          \"action\": \"mark platform as stepped on\"\n        },\n        {\n          \"action\": \"start countdown to platform falling\"\n        }\n      ]\n    },\n    {\n      \"name\": \"initiate_platform_fall\",\n      \"trigger\": \"after fall delay has elapsed\",\n      \"actions\": [\n        {\n          \"action\": \"disable platform collider\"\n        },\n        {\n          \"action\": \"enable platform gravity\"\n        },\n        {\n          \"action\": \"drop platform downward at increasing speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"destroy_platform\",\n      \"trigger\": \"when platform falls below game area\",\n      \"actions\": [\n        {\n          \"action\": \"remove platform from game world\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class CrumblingPlatform : MonoBehaviour\n{\n    [SerializeField] private float fallDelay = 0.5f;\n    [SerializeField] private float fallSpeed = 5f;\n    [SerializeField] private float destroyDelay = 2f;\n\n    private Rigidbody2D rb;\n    private bool hasBeenTriggered = false;\n    private bool isFalling = false;\n\n    private void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        \n        // Ensure rigidbody is set to kinematic initially\n        if (rb != null)\n        {\n            rb.isKinematic = true;\n        }\n    }\n\n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        // Check if platform hasn't been triggered and player is on top\n        if (!hasBeenTriggered && collision.gameObject.CompareTag(\"Player\"))\n        {\n            hasBeenTriggered = true;\n            Invoke(nameof(StartFalling), fallDelay);\n        }\n    }\n\n    private void StartFalling()\n    {\n        if (rb != null)\n        {\n            rb.isKinematic = false;\n            isFalling = true;\n        }\n\n        // Destroy platform after falling\n        Destroy(gameObject, destroyDelay);\n    }\n\n    private void FixedUpdate()\n    {\n        // Apply falling movement if triggered\n        if (isFalling && rb != null)\n        {\n            rb.velocity = Vector2.down * fallSpeed;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ProjectileWeapon\",\n  \"components\": [\n    \"Weapon\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"fireRate\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"projectilePrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"projectileSpeed\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"magazineSize\",\n      \"type\": \"int\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"currentAmmo\",\n      \"type\": \"int\",\n      \"default\": 30\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"fire_weapon\",\n      \"trigger\": \"player presses fire button\",\n      \"actions\": [\n        {\n          \"action\": \"check if weapon has ammo\"\n        },\n        {\n          \"action\": \"spawn projectile from weapon barrel\"\n        },\n        {\n          \"action\": \"apply forward velocity to projectile\"\n        },\n        {\n          \"action\": \"play firing sound\"\n        },\n        {\n          \"action\": \"create muzzle flash particle effect\"\n        },\n        {\n          \"action\": \"reduce current ammo count\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reload_weapon\",\n      \"trigger\": \"player presses reload button or ammo is empty\",\n      \"actions\": [\n        {\n          \"action\": \"reset current ammo to full magazine size\"\n        },\n        {\n          \"action\": \"play reload sound\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class GunController : MonoBehaviour\n{\n    [SerializeField] private GameObject projectilePrefab;\n    [SerializeField] private Transform firePoint;\n    [SerializeField] private float projectileSpeed = 20f;\n    [SerializeField] private float fireRate = 0.5f;\n    [SerializeField] private bool isAutomatic = false;\n\n    private float nextFireTime = 0f;\n\n    private void Update()\n    {\n        // Check if gun should fire based on input and fire rate\n        if (CanFire())\n        {\n            Fire();\n        }\n    }\n\n    private bool CanFire()\n    {\n        // Check for single shot or automatic fire\n        if (isAutomatic && Input.GetButton(\"Fire1\"))\n        {\n            return Time.time >= nextFireTime;\n        }\n        else if (!isAutomatic && Input.GetButtonDown(\"Fire1\"))\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    private void Fire()\n    {\n        // Validate fire point and projectile prefab\n        if (firePoint == null || projectilePrefab == null)\n        {\n            Debug.LogWarning(\"Fire point or projectile prefab is not set!\");\n            return;\n        }\n\n        // Instantiate projectile\n        GameObject projectile = Instantiate(projectilePrefab, firePoint.position, firePoint.rotation);\n        \n        // Add velocity to projectile\n        Rigidbody projectileRb = projectile.GetComponent<Rigidbody>();\n        if (projectileRb != null)\n        {\n            projectileRb.velocity = firePoint.forward * projectileSpeed;\n        }\n\n        // Set next fire time for fire rate control\n        nextFireTime = Time.time + fireRate;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"StealthAmbusher\",\n  \"components\": [\n    \"NavMeshAgent\",\n    \"Animator\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRange\",\n      \"type\": \"float\",\n      \"default\": 8.0\n    },\n    {\n      \"name\": \"hidingSpotOffset\",\n      \"type\": \"float\",\n      \"default\": 3.5\n    },\n    {\n      \"name\": \"ambushDamage\",\n      \"type\": \"float\",\n      \"default\": 25.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"hide_in_environment\",\n      \"trigger\": \"when patrol area is clear of player\",\n      \"actions\": [\n        {\n          \"action\": \"blend into nearby shadows or cover\"\n        },\n        {\n          \"action\": \"reduce movement visibility\"\n        },\n        {\n          \"action\": \"minimize sound generation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"detect_player_proximity\",\n      \"trigger\": \"when player enters detection range\",\n      \"actions\": [\n        {\n          \"action\": \"slowly turn toward player's location\"\n        },\n        {\n          \"action\": \"prepare ambush stance\"\n        },\n        {\n          \"action\": \"suppress movement sounds\"\n        }\n      ]\n    },\n    {\n      \"name\": \"execute_ambush\",\n      \"trigger\": \"when player is very close and unaware\",\n      \"actions\": [\n        {\n          \"action\": \"rapidly leap from hiding spot\"\n        },\n        {\n          \"action\": \"play sudden attack animation\"\n        },\n        {\n          \"action\": \"deal high damage to player\"\n        },\n        {\n          \"action\": \"trigger surprise sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"retreat_after_attack\",\n      \"trigger\": \"if ambush attack is successful\",\n      \"actions\": [\n        {\n          \"action\": \"quickly move back to previous hiding location\"\n        },\n        {\n          \"action\": \"reset stealth state\"\n        },\n        {\n          \"action\": \"wait for next opportunity\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.AI;\n\npublic class StealthEnemyController : MonoBehaviour\n{\n    [Header(\"Detection Settings\")]\n    [SerializeField] private float detectionRadius = 10f;\n    [SerializeField] private float ambushDetectionRange = 5f;\n    [SerializeField] private LayerMask playerLayer;\n\n    [Header(\"Movement Settings\")]\n    [SerializeField] private NavMeshAgent agent;\n    [SerializeField] private float patrolSpeed = 2f;\n    [SerializeField] private float chaseSpeed = 5f;\n\n    [Header(\"State Management\")]\n    [SerializeField] private bool isAmbushing = false;\n    [SerializeField] private float ambushCooldown = 10f;\n\n    private Transform playerTransform;\n    private Vector3 initialPosition;\n    private float lastAmbushTime;\n\n    private enum EnemyState\n    {\n        Patrolling,\n        Hiding,\n        Chasing,\n        Ambushing\n    }\n    private EnemyState currentState = EnemyState.Patrolling;\n\n    private void Start()\n    {\n        playerTransform = GameObject.FindGameObjectWithTag(\"Player\").transform;\n        initialPosition = transform.position;\n        agent = GetComponent<NavMeshAgent>();\n        agent.speed = patrolSpeed;\n    }\n\n    private void Update()\n    {\n        switch (currentState)\n        {\n            case EnemyState.Patrolling:\n                HandlePatrolling();\n                break;\n            case EnemyState.Hiding:\n                HandleHiding();\n                break;\n            case EnemyState.Chasing:\n                HandleChasing();\n                break;\n            case EnemyState.Ambushing:\n                HandleAmbushing();\n                break;\n        }\n    }\n\n    private void HandlePatrolling()\n    {\n        if (Vector3.Distance(transform.position, playerTransform.position) <= detectionRadius)\n        {\n            currentState = EnemyState.Hiding;\n        }\n        else\n        {\n            // Simple patrol logic\n            if (!agent.pathPending && agent.remainingDistance < 0.5f)\n            {\n                Vector3 randomDirection = Random.insideUnitSphere * 10f;\n                randomDirection += initialPosition;\n                NavMeshHit hit;\n                NavMesh.SamplePosition(randomDirection, out hit, 10f, NavMesh.AllAreas);\n                agent.SetDestination(hit.position);\n            }\n        }\n    }\n\n    private void HandleHiding()\n    {\n        if (Vector3.Distance(transform.position, playerTransform.position) <= ambushDetectionRange)\n        {\n            if (Time.time - lastAmbushTime > ambushCooldown)\n            {\n                currentState = EnemyState.Ambushing;\n                lastAmbushTime = Time.time;\n            }\n            else\n            {\n                currentState = EnemyState.Chasing;\n            }\n        }\n        else if (Vector3.Distance(transform.position, playerTransform.position) > detectionRadius)\n        {\n            currentState = EnemyState.Patrolling;\n        }\n    }\n\n    private void HandleChasing()\n    {\n        agent.speed = chaseSpeed;\n        agent.SetDestination(playerTransform.position);\n\n        if (Vector3.Distance(transform.position, playerTransform.position) > detectionRadius)\n        {\n            currentState = EnemyState.Patrolling;\n        }\n    }\n\n    private void HandleAmbushing()\n    {\n        agent.isStopped = true;\n        \n        if (Vector3.Distance(transform.position, playerTransform.position) <= ambushDetectionRange)\n        {\n            // Perform ambush attack\n            PlayerDetected();\n        }\n        else\n        {\n            currentState = EnemyState.Hiding;\n            agent.isStopped = false;\n        }\n    }\n\n    private void PlayerDetected()\n    {\n        // Implement attack logic\n        Debug.Log(\"Ambush Attack!\");\n        // Potentially damage player or trigger special attack\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, detectionRadius);\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, ambushDetectionRange);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ObjectiveMarker\",\n  \"components\": [\n    \"RectTransform\",\n    \"Image\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"objectiveType\",\n      \"type\": \"string\",\n      \"default\": \"\"\n    },\n    {\n      \"name\": \"isCompleted\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"markerColor\",\n      \"type\": \"color\",\n      \"default\": \"blue\"\n    },\n    {\n      \"name\": \"minimapRadius\",\n      \"type\": \"float\",\n      \"default\": 100\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"update_marker_position\",\n      \"trigger\": \"when objective location changes in game world\",\n      \"actions\": [\n        {\n          \"action\": \"reposition marker on minimap based on world coordinates\"\n        },\n        {\n          \"action\": \"adjust marker visibility depending on objective status\"\n        }\n      ]\n    },\n    {\n      \"name\": \"mark_objective_complete\",\n      \"trigger\": \"when objective requirements are fulfilled\",\n      \"actions\": [\n        {\n          \"action\": \"change marker color to completed state\"\n        },\n        {\n          \"action\": \"fade marker to indicate finished status\"\n        },\n        {\n          \"action\": \"play subtle completion animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"highlight_active_objective\",\n      \"trigger\": \"when player selects or focuses on objective\",\n      \"actions\": [\n        {\n          \"action\": \"increase marker size temporarily\"\n        },\n        {\n          \"action\": \"add pulsing visual effect\"\n        },\n        {\n          \"action\": \"show additional objective details\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class MinimapObjectiveMarker : MonoBehaviour\n{\n    [SerializeField] private GameObject markerPrefab;\n    [SerializeField] private Color objectiveColor = Color.red;\n    [SerializeField] private float markerScale = 1f;\n    [SerializeField] private bool isActive = true;\n\n    private GameObject minimapMarker;\n    private Camera minimapCamera;\n\n    private void Start()\n    {\n        // Find minimap camera if not assigned\n        if (minimapCamera == null)\n        {\n            minimapCamera = GameObject.FindGameObjectWithTag(\"MinimapCamera\")?.GetComponent<Camera>();\n        }\n\n        // Instantiate marker if prefab is set\n        if (markerPrefab != null)\n        {\n            CreateMinimapMarker();\n        }\n    }\n\n    private void Update()\n    {\n        // Update marker position and visibility if active\n        if (isActive && minimapMarker != null && minimapCamera != null)\n        {\n            UpdateMarkerPosition();\n        }\n    }\n\n    private void CreateMinimapMarker()\n    {\n        minimapMarker = Instantiate(markerPrefab, Vector3.zero, Quaternion.identity);\n        \n        // Set marker color\n        Renderer markerRenderer = minimapMarker.GetComponent<Renderer>();\n        if (markerRenderer != null)\n        {\n            markerRenderer.material.color = objectiveColor;\n        }\n\n        // Scale marker\n        minimapMarker.transform.localScale = Vector3.one * markerScale;\n    }\n\n    private void UpdateMarkerPosition()\n    {\n        // Convert world position to minimap screen position\n        Vector3 screenPos = minimapCamera.WorldToViewportPoint(transform.position);\n        \n        // Check if marker is within minimap bounds\n        if (IsWithinMinimapBounds(screenPos))\n        {\n            minimapMarker.SetActive(true);\n            minimapMarker.transform.position = screenPos;\n        }\n        else\n        {\n            minimapMarker.SetActive(false);\n        }\n    }\n\n    private bool IsWithinMinimapBounds(Vector3 viewportPos)\n    {\n        return viewportPos.x >= 0 && viewportPos.x <= 1 &&\n               viewportPos.y >= 0 && viewportPos.y <= 1 &&\n               viewportPos.z > 0;\n    }\n\n    public void SetObjectiveActive(bool active)\n    {\n        isActive = active;\n        \n        if (minimapMarker != null)\n        {\n            minimapMarker.SetActive(active);\n        }\n    }\n\n    private void OnDestroy()\n    {\n        // Clean up marker when objective is destroyed\n        if (minimapMarker != null)\n        {\n            Destroy(minimapMarker);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PlayerMovement\",\n  \"components\": [\n    \"CharacterController\",\n    \"Stamina\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"walkSpeed\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"sprintSpeed\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"maxStamina\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"currentStamina\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"staminaDrainRate\",\n      \"type\": \"float\",\n      \"default\": 20\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"sprint_movement\",\n      \"trigger\": \"player holds sprint button and has stamina remaining\",\n      \"actions\": [\n        {\n          \"action\": \"increase movement speed to sprint speed\"\n        },\n        {\n          \"action\": \"reduce stamina by stamina drain rate per second\"\n        },\n        {\n          \"action\": \"stop sprinting if stamina is depleted\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stamina_recovery\",\n      \"trigger\": \"player is not sprinting and stamina is below maximum\",\n      \"actions\": [\n        {\n          \"action\": \"gradually restore stamina over time\"\n        },\n        {\n          \"action\": \"prevent stamina from exceeding maximum value\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SprintController : MonoBehaviour\n{\n    [Header(\"Stamina Settings\")]\n    [SerializeField] private float maxStamina = 100f;\n    [SerializeField] private float staminaDrainRate = 20f;\n    [SerializeField] private float staminaRegenRate = 10f;\n    [SerializeField] private float sprintMultiplier = 1.5f;\n\n    [Header(\"Movement References\")]\n    [SerializeField] private CharacterController characterController;\n    [SerializeField] private Transform playerTransform;\n\n    private float currentStamina;\n    private bool isSprinting;\n\n    private void Start()\n    {\n        // Initialize stamina to full\n        currentStamina = maxStamina;\n\n        // Validate references\n        if (characterController == null)\n            characterController = GetComponent<CharacterController>();\n    }\n\n    private void Update()\n    {\n        HandleSprintInput();\n        UpdateStamina();\n        ApplyMovement();\n    }\n\n    private void HandleSprintInput()\n    {\n        // Check if player wants to sprint and has stamina\n        isSprinting = Input.GetKey(KeyCode.LeftShift) && currentStamina > 0;\n    }\n\n    private void UpdateStamina()\n    {\n        if (isSprinting)\n        {\n            // Drain stamina while sprinting\n            currentStamina = Mathf.Max(0, currentStamina - staminaDrainRate * Time.deltaTime);\n        }\n        else\n        {\n            // Regenerate stamina when not sprinting\n            currentStamina = Mathf.Min(maxStamina, currentStamina + staminaRegenRate * Time.deltaTime);\n        }\n    }\n\n    private void ApplyMovement()\n    {\n        // Get basic movement input\n        float horizontalInput = Input.GetAxis(\"Horizontal\");\n        float verticalInput = Input.GetAxis(\"Vertical\");\n\n        // Calculate movement vector\n        Vector3 moveDirection = playerTransform.right * horizontalInput + playerTransform.forward * verticalInput;\n\n        // Apply sprint multiplier if sprinting and has stamina\n        float currentSpeed = isSprinting ? sprintMultiplier : 1f;\n\n        // Move the character\n        characterController.Move(moveDirection * currentSpeed * Time.deltaTime);\n    }\n\n    // Optional: Public method to get current stamina percentage\n    public float GetStaminaPercentage()\n    {\n        return currentStamina / maxStamina;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GroundPoundAttack\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"damage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"attackRadius\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"verticalLaunchForce\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"groundImpactDelay\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initiate_ground_pound\",\n      \"trigger\": \"when player presses special attack button\",\n      \"actions\": [\n        {\n          \"action\": \"launch character high into the air\"\n        },\n        {\n          \"action\": \"rotate character to face downward during aerial descent\"\n        },\n        {\n          \"action\": \"prepare ground pound stance\"\n        }\n      ]\n    },\n    {\n      \"name\": \"execute_ground_pound\",\n      \"trigger\": \"when character reaches maximum height and begins downward trajectory\",\n      \"actions\": [\n        {\n          \"action\": \"increase falling speed dramatically\"\n        },\n        {\n          \"action\": \"activate ground pound collision detection\"\n        }\n      ]\n    },\n    {\n      \"name\": \"impact_ground\",\n      \"trigger\": \"when character contacts ground surface\",\n      \"actions\": [\n        {\n          \"action\": \"create circular shockwave around impact point\"\n        },\n        {\n          \"action\": \"damage nearby enemies within attack radius\"\n        },\n        {\n          \"action\": \"apply knockback force to affected targets\"\n        },\n        {\n          \"action\": \"create ground impact visual effect\"\n        },\n        {\n          \"action\": \"generate ground tremor animation\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class GroundPoundAttack : MonoBehaviour\n{\n    [SerializeField] private float groundPoundForce = 10f;\n    [SerializeField] private float groundPoundRadius = 3f;\n    [SerializeField] private LayerMask damagableLayerMask;\n    [SerializeField] private float damageAmount = 50f;\n    [SerializeField] private float verticalAirTime = 0.5f;\n\n    private Rigidbody playerRigidbody;\n    private bool isGroundPounding = false;\n\n    private void Start()\n    {\n        playerRigidbody = GetComponent<Rigidbody>();\n    }\n\n    private void Update()\n    {\n        // Check for ground pound input\n        if (Input.GetButtonDown(\"GroundPound\") && !isGroundPounding)\n        {\n            InitiateGroundPound();\n        }\n    }\n\n    private void InitiateGroundPound()\n    {\n        isGroundPounding = true;\n        playerRigidbody.useGravity = true;\n        playerRigidbody.AddForce(Vector3.down * groundPoundForce, ForceMode.Impulse);\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        if (isGroundPounding)\n        {\n            PerformGroundPoundEffect();\n        }\n    }\n\n    private void PerformGroundPoundEffect()\n    {\n        // Apply damage to nearby enemies\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, groundPoundRadius, damagableLayerMask);\n\n        foreach (Collider hitCollider in hitColliders)\n        {\n            IDamageable damageable = hitCollider.GetComponent<IDamageable>();\n            if (damageable != null)\n            {\n                damageable.TakeDamage(damageAmount);\n            }\n        }\n\n        // Apply knockback force\n        Rigidbody[] rigidbodies = Physics.OverlapSphere(transform.position, groundPoundRadius)\n            .Select(c => c.GetComponent<Rigidbody>())\n            .Where(rb => rb != null)\n            .ToArray();\n\n        foreach (Rigidbody rb in rigidbodies)\n        {\n            Vector3 knockbackDirection = (rb.transform.position - transform.position).normalized;\n            rb.AddForce(knockbackDirection * groundPoundForce, ForceMode.Impulse);\n        }\n\n        // Reset ground pound state\n        isGroundPounding = false;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        // Visualize ground pound radius in editor\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, groundPoundRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ExperienceOrb\",\n  \"components\": [\n    \"Collider\",\n    \"SpriteRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"experienceAmount\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"floatSpeed\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 45\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"hover_behavior\",\n      \"trigger\": \"continuously while orb exists\",\n      \"actions\": [\n        {\n          \"action\": \"gently float up and down\"\n        },\n        {\n          \"action\": \"slowly rotate in place\"\n        }\n      ]\n    },\n    {\n      \"name\": \"collection_behavior\",\n      \"trigger\": \"when player touches orb\",\n      \"actions\": [\n        {\n          \"action\": \"add experience points to player's total\"\n        },\n        {\n          \"action\": \"play pickup sound effect\"\n        },\n        {\n          \"action\": \"create small particle burst\"\n        },\n        {\n          \"action\": \"destroy this orb\"\n        }\n      ]\n    },\n    {\n      \"name\": \"despawn_behavior\",\n      \"trigger\": \"after certain time period\",\n      \"actions\": [\n        {\n          \"action\": \"fade out gradually\"\n        },\n        {\n          \"action\": \"delete orb from game world\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class ExperienceOrb : MonoBehaviour\n{\n    [SerializeField] private float experienceAmount = 10f;\n    [SerializeField] private float moveSpeed = 5f;\n    [SerializeField] private float magnetRadius = 3f;\n\n    private Transform playerTransform;\n    private bool isBeingCollected;\n\n    private void Start()\n    {\n        // Find the player on spawn\n        playerTransform = GameObject.FindGameObjectWithTag(\"Player\").transform;\n    }\n\n    private void Update()\n    {\n        // Check if player is close enough to attract orb\n        if (playerTransform != null)\n        {\n            float distanceToPlayer = Vector3.Distance(transform.position, playerTransform.position);\n\n            if (distanceToPlayer <= magnetRadius)\n            {\n                MoveTowardsPlayer();\n            }\n        }\n    }\n\n    private void MoveTowardsPlayer()\n    {\n        if (playerTransform != null)\n        {\n            transform.position = Vector3.MoveTowards(\n                transform.position, \n                playerTransform.position, \n                moveSpeed * Time.deltaTime\n            );\n        }\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        // Check if player collected the orb\n        if (other.CompareTag(\"Player\") && !isBeingCollected)\n        {\n            isBeingCollected = true;\n            CollectExperience(other.gameObject);\n        }\n    }\n\n    private void CollectExperience(GameObject player)\n    {\n        // Add experience to player's stats\n        PlayerExperience playerExp = player.GetComponent<PlayerExperience>();\n        \n        if (playerExp != null)\n        {\n            playerExp.AddExperience(experienceAmount);\n            Destroy(gameObject);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LaserBeam\",\n  \"components\": [\n    \"LineRenderer\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"beamDuration\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    },\n    {\n      \"name\": \"cooldownDuration\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"beamRange\",\n      \"type\": \"float\",\n      \"default\": 50.0\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"toggle_beam\",\n      \"trigger\": \"when activation button is pressed\",\n      \"actions\": [\n        {\n          \"action\": \"switch laser beam on and off\"\n        },\n        {\n          \"action\": \"play activation sound effect\"\n        },\n        {\n          \"action\": \"render laser line from origin point\"\n        }\n      ]\n    },\n    {\n      \"name\": \"beam_cycle\",\n      \"trigger\": \"after beam duration expires\",\n      \"actions\": [\n        {\n          \"action\": \"deactivate laser beam\"\n        },\n        {\n          \"action\": \"start cooldown timer\"\n        },\n        {\n          \"action\": \"disable line renderer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"beam_damage\",\n      \"trigger\": \"while laser beam is active and touching target\",\n      \"actions\": [\n        {\n          \"action\": \"apply damage to intersecting objects\"\n        },\n        {\n          \"action\": \"create visual burn effect at contact point\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class LaserBeam : MonoBehaviour\n{\n    [SerializeField] private LineRenderer laserLine;\n    [SerializeField] private Transform laserOrigin;\n    [SerializeField] private Transform laserTarget;\n    [SerializeField] private float laserRange = 100f;\n    [SerializeField] private Color activeColor = Color.red;\n    [SerializeField] private Color inactiveColor = Color.gray;\n    [SerializeField] private float toggleInterval = 2f;\n\n    private bool isLaserActive = false;\n    private float toggleTimer = 0f;\n\n    private void Start()\n    {\n        // Validate required components\n        if (laserLine == null)\n        {\n            laserLine = GetComponent<LineRenderer>();\n        }\n\n        if (laserLine == null)\n        {\n            Debug.LogError(\"LaserBeam requires a LineRenderer component!\");\n            enabled = false;\n            return;\n        }\n\n        ConfigureLaserLine();\n        SetLaserState(false);\n    }\n\n    private void Update()\n    {\n        // Automatic toggle logic\n        toggleTimer += Time.deltaTime;\n        if (toggleTimer >= toggleInterval)\n        {\n            ToggleLaser();\n            toggleTimer = 0f;\n        }\n\n        if (isLaserActive)\n        {\n            UpdateLaserPosition();\n        }\n    }\n\n    private void ConfigureLaserLine()\n    {\n        laserLine.startWidth = 0.1f;\n        laserLine.endWidth = 0.1f;\n        laserLine.positionCount = 2;\n    }\n\n    private void UpdateLaserPosition()\n    {\n        if (laserOrigin == null || laserTarget == null)\n        {\n            return;\n        }\n\n        laserLine.SetPosition(0, laserOrigin.position);\n\n        RaycastHit hit;\n        if (Physics.Raycast(laserOrigin.position, laserOrigin.forward, out hit, laserRange))\n        {\n            laserLine.SetPosition(1, hit.point);\n        }\n        else\n        {\n            Vector3 endPoint = laserOrigin.position + laserOrigin.forward * laserRange;\n            laserLine.SetPosition(1, endPoint);\n        }\n    }\n\n    public void ToggleLaser()\n    {\n        isLaserActive = !isLaserActive;\n        SetLaserState(isLaserActive);\n    }\n\n    private void SetLaserState(bool active)\n    {\n        if (laserLine == null)\n        {\n            return;\n        }\n\n        laserLine.enabled = active;\n        laserLine.startColor = active ? activeColor : inactiveColor;\n        laserLine.endColor = active ? activeColor : inactiveColor;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SlidingTilePuzzle\",\n  \"components\": [\n    \"Grid\",\n    \"AudioSource\",\n    \"ScoreTracker\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"gridSize\",\n      \"type\": \"int\",\n      \"default\": 4\n    },\n    {\n      \"name\": \"emptyTilePosition\",\n      \"type\": \"vector2\",\n      \"default\": \"bottom right corner\"\n    },\n    {\n      \"name\": \"movesCount\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"shuffleDifficulty\",\n      \"type\": \"float\",\n      \"default\": 50\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initialize_puzzle\",\n      \"trigger\": \"when game starts\",\n      \"actions\": [\n        {\n          \"action\": \"create grid of numbered tiles\"\n        },\n        {\n          \"action\": \"randomize tile positions\"\n        },\n        {\n          \"action\": \"ensure puzzle is solvable\"\n        }\n      ]\n    },\n    {\n      \"name\": \"handle_tile_selection\",\n      \"trigger\": \"when player taps a tile\",\n      \"actions\": [\n        {\n          \"action\": \"check if selected tile can slide\"\n        },\n        {\n          \"action\": \"swap selected tile with empty tile\"\n        },\n        {\n          \"action\": \"increment moves counter\"\n        },\n        {\n          \"action\": \"play sliding sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"check_puzzle_completion\",\n      \"trigger\": \"after each tile movement\",\n      \"actions\": [\n        {\n          \"action\": \"verify all tiles are in correct numerical order\"\n        },\n        {\n          \"action\": \"if puzzle solved, trigger victory sequence\"\n        },\n        {\n          \"action\": \"record total moves and time\"\n        }\n      ]\n    },\n    {\n      \"name\": \"shuffle_puzzle\",\n      \"trigger\": \"when player requests new puzzle\",\n      \"actions\": [\n        {\n          \"action\": \"randomly reposition tiles\"\n        },\n        {\n          \"action\": \"reset moves counter\"\n        },\n        {\n          \"action\": \"ensure new configuration is solvable\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class SlidingTilePuzzle : MonoBehaviour\n{\n    [SerializeField] private int gridSize = 4;\n    [SerializeField] private GameObject tilePrefab;\n    [SerializeField] private float tileSpacing = 1.1f;\n\n    private GameObject[,] tiles;\n    private Vector2Int emptyTilePosition;\n\n    private void Start()\n    {\n        InitializePuzzleGrid();\n        ShufflePuzzle();\n    }\n\n    private void InitializePuzzleGrid()\n    {\n        tiles = new GameObject[gridSize, gridSize];\n\n        for (int row = 0; row < gridSize; row++)\n        {\n            for (int col = 0; col < gridSize; col++)\n            {\n                if (row == gridSize - 1 && col == gridSize - 1)\n                {\n                    emptyTilePosition = new Vector2Int(row, col);\n                    continue;\n                }\n\n                GameObject tile = Instantiate(tilePrefab, transform);\n                tile.name = $\"Tile_{row}_{col}\";\n                tile.GetComponent<TileController>().SetTileNumber(row * gridSize + col + 1);\n\n                Vector3 position = new Vector3(\n                    col * tileSpacing,\n                    -row * tileSpacing,\n                    0\n                );\n                tile.transform.localPosition = position;\n\n                tiles[row, col] = tile;\n            }\n        }\n    }\n\n    private void ShufflePuzzle()\n    {\n        for (int i = 0; i < 100; i++)\n        {\n            List<Vector2Int> validMoves = GetValidMoves();\n            if (validMoves.Count > 0)\n            {\n                Vector2Int randomMove = validMoves[Random.Range(0, validMoves.Count)];\n                MoveTile(randomMove);\n            }\n        }\n    }\n\n    private List<Vector2Int> GetValidMoves()\n    {\n        List<Vector2Int> validMoves = new List<Vector2Int>();\n        int[][] directions = new int[][] \n        {\n            new int[] { -1, 0 }, // Up\n            new int[] { 1, 0 },  // Down\n            new int[] { 0, -1 }, // Left\n            new int[] { 0, 1 }   // Right\n        };\n\n        foreach (int[] dir in directions)\n        {\n            int newRow = emptyTilePosition.x + dir[0];\n            int newCol = emptyTilePosition.y + dir[1];\n\n            if (IsValidPosition(newRow, newCol))\n            {\n                validMoves.Add(new Vector2Int(newRow, newCol));\n            }\n        }\n\n        return validMoves;\n    }\n\n    private bool IsValidPosition(int row, int col)\n    {\n        return row >= 0 && row < gridSize && col >= 0 && col < gridSize;\n    }\n\n    private void MoveTile(Vector2Int tilePosition)\n    {\n        if (tiles[tilePosition.x, tilePosition.y] == null)\n            return;\n\n        // Swap tile positions\n        tiles[emptyTilePosition.x, emptyTilePosition.y] = tiles[tilePosition.x, tilePosition.y];\n        tiles[tilePosition.x, tilePosition.y] = null;\n\n        // Update tile's visual position\n        Vector3 targetPosition = tiles[emptyTilePosition.x, emptyTilePosition.y].transform.localPosition;\n        tiles[emptyTilePosition.x, emptyTilePosition.y].transform.localPosition = \n            new Vector3(\n                emptyTilePosition.y * tileSpacing, \n                -emptyTilePosition.x * tileSpacing, \n                0\n            );\n\n        // Update empty tile position\n        emptyTilePosition = tilePosition;\n    }\n\n    private void Update()\n    {\n        HandleInput();\n    }\n\n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0))\n        {\n            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);\n            RaycastHit2D hit = Physics2D.Raycast(ray.origin, ray.direction);\n\n            if (hit.collider != null)\n            {\n                TileController tileController = hit.collider.GetComponent<TileController>();\n                if (tileController != null)\n                {\n                    Vector2Int tilePosition = FindTilePosition(tileController.gameObject);\n                    if (IsAdjacentToEmptyTile(tilePosition))\n                    {\n                        MoveTile(tilePosition);\n                    }\n                }\n            }\n        }\n    }\n\n    private Vector2Int FindTilePosition(GameObject tile)\n    {\n        for (int row = 0; row < gridSize; row++)\n        {\n            for (int col = 0; col < gridSize; col++)\n            {\n                if (tiles[row, col] == tile)\n                {\n                    return new Vector2Int(row, col);\n                }\n            }\n        }\n        return new Vector2Int(-1, -1);\n    }\n\n    private bool IsAdjacentToEmptyTile(Vector2Int tilePosition)\n    {\n        return Mathf.Abs(tilePosition.x - emptyTilePosition.x) + \n               Mathf.Abs(tilePosition.y - emptyTilePosition.y) == 1;\n    }\n\n    private bool CheckPuzzleSolved()\n    {\n        for (int row = 0; row < gridSize; row++)\n        {\n            for (int col = 0; col < gridSize; col++)\n            {\n                if (row == gridSize - 1 && col == gridSize - 1)\n                    continue;\n\n                TileController tileController = tiles[row, col].GetComponent<TileController>();\n                if (tileController.TileNumber != row * gridSize + col + 1)\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MeleeWeapon\",\n  \"components\": [\n    \"Weapon\",\n    \"AudioSource\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"baseDamage\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"comboWindowTime\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"currentComboStep\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"maxComboSteps\",\n      \"type\": \"int\",\n      \"default\": 3\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_primary_attack\",\n      \"trigger\": \"player presses primary attack button\",\n      \"actions\": [\n        {\n          \"action\": \"begin first attack animation\"\n        },\n        {\n          \"action\": \"play weapon swing sound effect\"\n        },\n        {\n          \"action\": \"deal damage to target in attack range\"\n        }\n      ]\n    },\n    {\n      \"name\": \"execute_combo_attack\",\n      \"trigger\": \"player presses attack button during combo window\",\n      \"actions\": [\n        {\n          \"action\": \"advance to next combo step\"\n        },\n        {\n          \"action\": \"play next attack animation in combo sequence\"\n        },\n        {\n          \"action\": \"increase damage for subsequent combo hits\"\n        },\n        {\n          \"action\": \"reset combo window timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_combo\",\n      \"trigger\": \"combo window expires without additional attacks\",\n      \"actions\": [\n        {\n          \"action\": \"reset current combo step to zero\"\n        },\n        {\n          \"action\": \"return to idle weapon state\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class MeleeWeapon : MonoBehaviour\n{\n    [SerializeField] private float baseDamage = 10f;\n    [SerializeField] private float attackRange = 2f;\n    [SerializeField] private LayerMask enemyLayer;\n\n    [Header(\"Combo Attack Settings\")]\n    [SerializeField] private float[] comboDamageMultipliers = { 1f, 1.2f, 1.5f };\n    [SerializeField] private float comboWindowTime = 0.5f;\n\n    private int currentComboIndex = 0;\n    private float lastAttackTime;\n    private Animator animator;\n\n    private void Start()\n    {\n        animator = GetComponent<Animator>();\n    }\n\n    private void Update()\n    {\n        // Check for attack input\n        if (Input.GetButtonDown(\"Fire1\"))\n        {\n            PerformAttack();\n        }\n    }\n\n    private void PerformAttack()\n    {\n        // Reset combo if time window has passed\n        if (Time.time - lastAttackTime > comboWindowTime)\n        {\n            currentComboIndex = 0;\n        }\n\n        // Perform attack\n        float currentDamage = baseDamage * comboDamageMultipliers[currentComboIndex];\n        \n        // Trigger attack animation\n        if (animator != null)\n        {\n            animator.SetTrigger($\"Attack{currentComboIndex + 1}\");\n        }\n\n        // Perform raycast attack\n        Collider[] hitEnemies = Physics.OverlapSphere(transform.position, attackRange, enemyLayer);\n        \n        foreach (Collider enemy in hitEnemies)\n        {\n            IDamageable damageable = enemy.GetComponent<IDamageable>();\n            damageable?.TakeDamage(currentDamage);\n        }\n\n        // Increment combo index\n        currentComboIndex = (currentComboIndex + 1) % comboDamageMultipliers.Length;\n        lastAttackTime = Time.time;\n    }\n\n    // Optional: Visualize attack range in scene view\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, attackRange);\n    }\n}\n\n// Optional interface for damage handling\npublic interface IDamageable\n{\n    void TakeDamage(float damage);\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"AmmunitionBox\",\n  \"components\": [\n    \"BoxCollider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"ammoRefillAmount\",\n      \"type\": \"int\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"refillRadius\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    },\n    {\n      \"name\": \"canBeUsedMultipleTimes\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player_proximity\",\n      \"trigger\": \"when player enters ammunition box interaction range\",\n      \"actions\": [\n        {\n          \"action\": \"play pickup sound effect\"\n        },\n        {\n          \"action\": \"increase player's current weapon ammunition\"\n        },\n        {\n          \"action\": \"show visual feedback of ammunition refill\"\n        }\n      ]\n    },\n    {\n      \"name\": \"manage_box_depletion\",\n      \"trigger\": \"after ammunition has been refilled\",\n      \"actions\": [\n        {\n          \"action\": \"if box is single-use, disable further interactions\"\n        },\n        {\n          \"action\": \"if box is multi-use, reset cooldown timer\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class AmmoBox : MonoBehaviour\n{\n    [SerializeField] private int ammoAmount = 30;\n    [SerializeField] private AudioClip pickupSound;\n    [SerializeField] private ParticleSystem pickupEffect;\n\n    private void OnTriggerEnter(Collider other)\n    {\n        // Check if the colliding object is a player\n        PlayerWeapon playerWeapon = other.GetComponent<PlayerWeapon>();\n        \n        if (playerWeapon != null)\n        {\n            // Refill weapon ammunition\n            if (playerWeapon.RefillAmmo(ammoAmount))\n            {\n                PlayPickupEffects();\n                Destroy(gameObject);\n            }\n        }\n    }\n\n    private void PlayPickupEffects()\n    {\n        // Play sound effect if assigned\n        if (pickupSound != null)\n        {\n            AudioSource.PlayClipAtPoint(pickupSound, transform.position);\n        }\n\n        // Spawn particle effect if assigned\n        if (pickupEffect != null)\n        {\n            Instantiate(pickupEffect, transform.position, Quaternion.identity);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Boomerang\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"throwForce\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"returnSpeed\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"thrower\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"maxFlightDistance\",\n      \"type\": \"float\",\n      \"default\": 20\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"throw_boomerang\",\n      \"trigger\": \"player releases throw button\",\n      \"actions\": [\n        {\n          \"action\": \"launch boomerang in throwing direction\"\n        },\n        {\n          \"action\": \"apply initial throwing force\"\n        },\n        {\n          \"action\": \"start tracking flight distance\"\n        }\n      ]\n    },\n    {\n      \"name\": \"return_to_thrower\",\n      \"trigger\": \"boomerang reaches maximum flight distance\",\n      \"actions\": [\n        {\n          \"action\": \"change flight direction toward thrower\"\n        },\n        {\n          \"action\": \"gradually increase return speed\"\n        },\n        {\n          \"action\": \"rotate boomerang to face return trajectory\"\n        }\n      ]\n    },\n    {\n      \"name\": \"catch_boomerang\",\n      \"trigger\": \"boomerang is very close to thrower\",\n      \"actions\": [\n        {\n          \"action\": \"stop boomerang movement\"\n        },\n        {\n          \"action\": \"return boomerang to thrower's hand\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class BoomerangController : MonoBehaviour\n{\n    [SerializeField] private float throwForce = 10f;\n    [SerializeField] private float returnSpeed = 5f;\n    [SerializeField] private float maxThrowDistance = 20f;\n    [SerializeField] private float rotationSpeed = 500f;\n\n    private Vector3 throwOrigin;\n    private Transform thrower;\n    private Rigidbody rb;\n    private bool isReturning = false;\n\n    private void Awake()\n    {\n        rb = GetComponent<Rigidbody>();\n        rb.useGravity = false;\n    }\n\n    public void Throw(Transform throwerTransform)\n    {\n        if (throwerTransform == null) return;\n\n        thrower = throwerTransform;\n        throwOrigin = thrower.position;\n        isReturning = false;\n\n        // Apply initial throw force\n        Vector3 throwDirection = thrower.forward;\n        rb.isKinematic = false;\n        rb.AddForce(throwDirection * throwForce, ForceMode.Impulse);\n    }\n\n    private void Update()\n    {\n        // Continuous rotation\n        transform.Rotate(Vector3.forward * rotationSpeed * Time.deltaTime);\n\n        // Check return conditions\n        if (!isReturning && Vector3.Distance(throwOrigin, transform.position) >= maxThrowDistance)\n        {\n            StartReturn();\n        }\n    }\n\n    private void FixedUpdate()\n    {\n        if (isReturning && thrower != null)\n        {\n            // Smooth return to thrower\n            Vector3 returnDirection = (thrower.position - transform.position).normalized;\n            rb.velocity = returnDirection * returnSpeed;\n\n            // Check if boomerang is close enough to return\n            if (Vector3.Distance(transform.position, thrower.position) < 1f)\n            {\n                ReturnToThrower();\n            }\n        }\n    }\n\n    private void StartReturn()\n    {\n        isReturning = true;\n        rb.velocity = Vector3.zero;\n    }\n\n    private void ReturnToThrower()\n    {\n        rb.isKinematic = true;\n        rb.velocity = Vector3.zero;\n        transform.position = thrower.position;\n        gameObject.SetActive(false);\n    }\n\n    private void OnCollisionEnter(Collision collision)\n    {\n        // Optional: Add impact logic or damage\n        if (!isReturning)\n        {\n            StartReturn();\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"EnemySpawner\",\n  \"components\": [\n    \"Transform\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"spawnInterval\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"maxEnemies\",\n      \"type\": \"int\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"enemyPrefab\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"currentEnemyCount\",\n      \"type\": \"int\",\n      \"default\": 0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"periodic_spawn\",\n      \"trigger\": \"when spawn timer reaches interval\",\n      \"actions\": [\n        {\n          \"action\": \"check if current enemy count is below maximum\"\n        },\n        {\n          \"action\": \"create new enemy at spawner's location\"\n        },\n        {\n          \"action\": \"increment current enemy count\"\n        },\n        {\n          \"action\": \"reset spawn timer\"\n        }\n      ]\n    },\n    {\n      \"name\": \"enemy_destroyed\",\n      \"trigger\": \"when an enemy is removed from game\",\n      \"actions\": [\n        {\n          \"action\": \"decrement current enemy count\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections;\n\npublic class EnemySpawner : MonoBehaviour\n{\n    [SerializeField] private GameObject[] enemyPrefabs;\n    [SerializeField] private float spawnInterval = 3f;\n    [SerializeField] private Transform[] spawnPoints;\n    [SerializeField] private int maxEnemiesAtOnce = 10;\n\n    private int currentEnemyCount = 0;\n\n    private void Start()\n    {\n        // Validate configuration\n        if (enemyPrefabs == null || enemyPrefabs.Length == 0)\n        {\n            Debug.LogError(\"No enemy prefabs assigned to spawner!\");\n            enabled = false;\n            return;\n        }\n\n        if (spawnPoints == null || spawnPoints.Length == 0)\n        {\n            Debug.LogError(\"No spawn points assigned to spawner!\");\n            enabled = false;\n            return;\n        }\n\n        // Start spawning enemies\n        StartCoroutine(SpawnEnemiesRoutine());\n    }\n\n    private IEnumerator SpawnEnemiesRoutine()\n    {\n        while (true)\n        {\n            yield return new WaitForSeconds(spawnInterval);\n\n            if (currentEnemyCount < maxEnemiesAtOnce)\n            {\n                SpawnEnemy();\n            }\n        }\n    }\n\n    private void SpawnEnemy()\n    {\n        // Select random enemy prefab and spawn point\n        GameObject enemyToSpawn = enemyPrefabs[Random.Range(0, enemyPrefabs.Length)];\n        Transform spawnPoint = spawnPoints[Random.Range(0, spawnPoints.Length)];\n\n        // Instantiate enemy and track count\n        GameObject spawnedEnemy = Instantiate(enemyToSpawn, spawnPoint.position, spawnPoint.rotation);\n        \n        // Optional: Subscribe to enemy destruction to manage count\n        EnemyHealth enemyHealth = spawnedEnemy.GetComponent<EnemyHealth>();\n        if (enemyHealth != null)\n        {\n            enemyHealth.OnEnemyDied += HandleEnemyDeath;\n        }\n\n        currentEnemyCount++;\n    }\n\n    private void HandleEnemyDeath()\n    {\n        currentEnemyCount--;\n    }\n\n    private void OnDisable()\n    {\n        StopAllCoroutines();\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"IceFloor\",\n  \"components\": [\n    \"Collider\",\n    \"PhysicsMaterial\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"frictionReductionFactor\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    },\n    {\n      \"name\": \"slipperiness\",\n      \"type\": \"float\",\n      \"default\": 0.9\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"reduce_friction_on_contact\",\n      \"trigger\": \"when object touches ice surface\",\n      \"actions\": [\n        {\n          \"action\": \"dramatically lower object's friction\"\n        },\n        {\n          \"action\": \"increase object's sliding momentum\"\n        },\n        {\n          \"action\": \"make movement feel slippery and uncontrolled\"\n        }\n      ]\n    },\n    {\n      \"name\": \"apply_sliding_effect\",\n      \"trigger\": \"while object remains on ice surface\",\n      \"actions\": [\n        {\n          \"action\": \"gradually increase horizontal velocity\"\n        },\n        {\n          \"action\": \"reduce vertical movement stability\"\n        },\n        {\n          \"action\": \"simulate natural ice sliding physics\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class IceFloor : MonoBehaviour\n{\n    [SerializeField] private float frictionReductionFactor = 0.1f;\n    [SerializeField] private float slidingAcceleration = 5f;\n\n    private void OnCollisionStay(Collision collision)\n    {\n        Rigidbody rb = collision.gameObject.GetComponent<Rigidbody>();\n        \n        if (rb != null)\n        {\n            // Reduce friction for objects on the ice\n            rb.friction = frictionReductionFactor;\n\n            // Optional: Add subtle sliding effect\n            Vector3 currentVelocity = rb.velocity;\n            Vector3 surfaceDirection = transform.forward;\n            rb.AddForce(surfaceDirection * slidingAcceleration, ForceMode.Acceleration);\n        }\n    }\n\n    private void OnCollisionExit(Collision collision)\n    {\n        Rigidbody rb = collision.gameObject.GetComponent<Rigidbody>();\n        \n        if (rb != null)\n        {\n            // Reset friction when leaving ice surface\n            rb.friction = 1f;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SwimmerController\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxOxygen\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"currentOxygen\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"swimSpeed\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"underwaterDrag\",\n      \"type\": \"float\",\n      \"default\": 0.8\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"swim_movement\",\n      \"trigger\": \"player is underwater and pressing movement controls\",\n      \"actions\": [\n        {\n          \"action\": \"move swimmer in direction of input controls\"\n        },\n        {\n          \"action\": \"apply underwater movement resistance\"\n        },\n        {\n          \"action\": \"reduce oxygen level gradually\"\n        }\n      ]\n    },\n    {\n      \"name\": \"oxygen_depletion\",\n      \"trigger\": \"swimmer remains underwater\",\n      \"actions\": [\n        {\n          \"action\": \"decrease oxygen meter over time\"\n        },\n        {\n          \"action\": \"play low oxygen warning sound when oxygen is below 25 percent\"\n        },\n        {\n          \"action\": \"start taking damage when oxygen reaches zero\"\n        }\n      ]\n    },\n    {\n      \"name\": \"surface_oxygen_recovery\",\n      \"trigger\": \"swimmer reaches water surface\",\n      \"actions\": [\n        {\n          \"action\": \"rapidly restore oxygen meter\"\n        },\n        {\n          \"action\": \"stop damage from oxygen depletion\"\n        },\n        {\n          \"action\": \"play oxygen recovery sound\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SwimmingController : MonoBehaviour\n{\n    [Header(\"Swimming Settings\")]\n    [SerializeField] private float swimSpeed = 5f;\n    [SerializeField] private float underwaterDrag = 3f;\n    [SerializeField] private float surfaceDrag = 1f;\n\n    [Header(\"Oxygen System\")]\n    [SerializeField] private float maxOxygen = 100f;\n    [SerializeField] private float oxygenDepletionRate = 10f;\n    [SerializeField] private float oxygenRecoveryRate = 20f;\n\n    private Rigidbody2D rb;\n    private float currentOxygen;\n    private bool isUnderwater;\n\n    private void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        currentOxygen = maxOxygen;\n    }\n\n    private void Update()\n    {\n        HandleOxygenSystem();\n        HandleSwimmingInput();\n    }\n\n    private void HandleSwimmingInput()\n    {\n        Vector2 moveInput = new Vector2(\n            Input.GetAxis(\"Horizontal\"),\n            Input.GetAxis(\"Vertical\")\n        );\n\n        if (isUnderwater)\n        {\n            rb.drag = underwaterDrag;\n            rb.AddForce(moveInput * swimSpeed, ForceMode2D.Force);\n        }\n        else\n        {\n            rb.drag = surfaceDrag;\n        }\n    }\n\n    private void HandleOxygenSystem()\n    {\n        if (isUnderwater)\n        {\n            currentOxygen -= oxygenDepletionRate * Time.deltaTime;\n        }\n        else\n        {\n            currentOxygen += oxygenRecoveryRate * Time.deltaTime;\n        }\n\n        currentOxygen = Mathf.Clamp(currentOxygen, 0f, maxOxygen);\n\n        if (currentOxygen <= 0)\n        {\n            // Player dies or takes damage\n            Die();\n        }\n    }\n\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if (collision.CompareTag(\"Water\"))\n        {\n            isUnderwater = true;\n        }\n    }\n\n    private void OnTriggerExit2D(Collider2D collision)\n    {\n        if (collision.CompareTag(\"Water\"))\n        {\n            isUnderwater = false;\n        }\n    }\n\n    private void Die()\n    {\n        // Implement player death logic\n        Debug.Log(\"Player ran out of oxygen!\");\n        // Could trigger game over, respawn, etc.\n    }\n\n    public float GetOxygenPercentage()\n    {\n        return currentOxygen / maxOxygen * 100f;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ScreenShaker\",\n  \"components\": [\n    \"Camera\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"shakeDuration\",\n      \"type\": \"float\",\n      \"default\": 0.3\n    },\n    {\n      \"name\": \"shakeMagnitude\",\n      \"type\": \"float\",\n      \"default\": 0.1\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"impact_screen_shake\",\n      \"trigger\": \"when object receives significant collision or damage\",\n      \"actions\": [\n        {\n          \"action\": \"start random camera position jittering\"\n        },\n        {\n          \"action\": \"gradually reduce shake intensity over time\"\n        },\n        {\n          \"action\": \"reset camera to original position when shake completes\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class ScreenShakeController : MonoBehaviour\n{\n    [SerializeField] private float shakeDuration = 0.2f;\n    [SerializeField] private float shakeMagnitude = 0.1f;\n    [SerializeField] private float dampingSpeed = 1.0f;\n\n    private Vector3 originalPosition;\n    private float currentShakeDuration;\n\n    private void Start()\n    {\n        originalPosition = transform.localPosition;\n    }\n\n    private void Update()\n    {\n        if (currentShakeDuration > 0)\n        {\n            transform.localPosition = originalPosition + Random.insideUnitSphere * shakeMagnitude;\n            currentShakeDuration -= Time.deltaTime * dampingSpeed;\n        }\n        else\n        {\n            currentShakeDuration = 0f;\n            transform.localPosition = originalPosition;\n        }\n    }\n\n    public void TriggerShake()\n    {\n        currentShakeDuration = shakeDuration;\n    }\n\n    public void TriggerShake(float duration, float magnitude)\n    {\n        shakeDuration = duration;\n        shakeMagnitude = magnitude;\n        currentShakeDuration = shakeDuration;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"GuardUnit\",\n  \"components\": [\n    \"Collider\",\n    \"Health\",\n    \"AlertSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"detectionRadius\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"alertCooldown\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"isAlerted\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"take_damage\",\n      \"trigger\": \"when guard receives damage from any source\",\n      \"actions\": [\n        {\n          \"action\": \"play pain animation\"\n        },\n        {\n          \"action\": \"trigger alert status to nearby guard units\"\n        },\n        {\n          \"action\": \"start searching for attacker's location\"\n        }\n      ]\n    },\n    {\n      \"name\": \"alert_nearby_units\",\n      \"trigger\": \"when guard is attacked and alert is not on cooldown\",\n      \"actions\": [\n        {\n          \"action\": \"broadcast warning signal to all nearby allies\"\n        },\n        {\n          \"action\": \"mark current location as potential threat zone\"\n        },\n        {\n          \"action\": \"start alert cooldown timer\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class GuardAlertSystem : MonoBehaviour\n{\n    [SerializeField] private float alertRadius = 15f;\n    [SerializeField] private float alertDuration = 10f;\n    [SerializeField] private LayerMask guardLayerMask;\n\n    private bool isUnderAttack = false;\n    private float alertTimer = 0f;\n\n    private void Update()\n    {\n        if (isUnderAttack)\n        {\n            alertTimer += Time.deltaTime;\n            if (alertTimer >= alertDuration)\n            {\n                ResetAlertState();\n            }\n        }\n    }\n\n    public void OnAttacked()\n    {\n        if (!isUnderAttack)\n        {\n            isUnderAttack = true;\n            alertTimer = 0f;\n            AlertNearbyGuards();\n        }\n    }\n\n    private void AlertNearbyGuards()\n    {\n        Collider[] nearbyGuards = Physics.OverlapSphere(transform.position, alertRadius, guardLayerMask);\n\n        foreach (Collider guardCollider in nearbyGuards)\n        {\n            GuardAlertSystem guardScript = guardCollider.GetComponent<GuardAlertSystem>();\n            if (guardScript != null && guardScript != this)\n            {\n                guardScript.RespondToAlert(transform.position);\n            }\n        }\n    }\n\n    private void RespondToAlert(Vector3 attackOrigin)\n    {\n        if (!isUnderAttack)\n        {\n            isUnderAttack = true;\n            alertTimer = 0f;\n            // Additional logic for guard response (e.g., chase, combat)\n        }\n    }\n\n    private void ResetAlertState()\n    {\n        isUnderAttack = false;\n        alertTimer = 0f;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.red;\n        Gizmos.DrawWireSphere(transform.position, alertRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CrouchCrawlController\",\n  \"components\": [\n    \"CharacterController\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"crouchSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    },\n    {\n      \"name\": \"standingHeight\",\n      \"type\": \"float\",\n      \"default\": 1.8\n    },\n    {\n      \"name\": \"crouchHeight\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"isCrouching\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"start_crouch\",\n      \"trigger\": \"player presses crouch button\",\n      \"actions\": [\n        {\n          \"action\": \"reduce character height to crouching height\"\n        },\n        {\n          \"action\": \"slow down movement speed\"\n        },\n        {\n          \"action\": \"set crouching state to true\"\n        },\n        {\n          \"action\": \"play crouching animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_crouch\",\n      \"trigger\": \"player releases crouch button and has clearance above\",\n      \"actions\": [\n        {\n          \"action\": \"restore character height to standing height\"\n        },\n        {\n          \"action\": \"return to normal movement speed\"\n        },\n        {\n          \"action\": \"set crouching state to false\"\n        },\n        {\n          \"action\": \"play standing up animation\"\n        }\n      ]\n    },\n    {\n      \"name\": \"crawl_movement\",\n      \"trigger\": \"player is crouching and moving\",\n      \"actions\": [\n        {\n          \"action\": \"move character at reduced crawl speed\"\n        },\n        {\n          \"action\": \"play low crawling animation\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class CrouchCrawlMovement : MonoBehaviour\n{\n    [Header(\"Movement Settings\")]\n    [SerializeField] private float normalHeight = 2f;\n    [SerializeField] private float crouchHeight = 1f;\n    [SerializeField] private float crawlHeight = 0.5f;\n    [SerializeField] private float crouchSpeed = 2f;\n    [SerializeField] private float crawlSpeed = 1f;\n\n    [Header(\"Input Settings\")]\n    [SerializeField] private KeyCode crouchKey = KeyCode.C;\n    [SerializeField] private KeyCode crawlKey = KeyCode.LeftControl;\n\n    private CharacterController characterController;\n    private Camera playerCamera;\n\n    private bool isCrouching = false;\n    private bool isCrawling = false;\n\n    private void Start()\n    {\n        characterController = GetComponent<CharacterController>();\n        playerCamera = Camera.main;\n\n        if (characterController == null)\n        {\n            Debug.LogError(\"CharacterController component is required!\");\n        }\n    }\n\n    private void Update()\n    {\n        HandleCrouchAndCrawl();\n        AdjustPlayerHeight();\n    }\n\n    private void HandleCrouchAndCrawl()\n    {\n        // Toggle crouch\n        if (Input.GetKeyDown(crouchKey))\n        {\n            isCrouching = !isCrouching;\n            isCrawling = false;\n        }\n\n        // Toggle crawl\n        if (Input.GetKeyDown(crawlKey))\n        {\n            isCrawling = !isCrawling;\n            isCrouching = false;\n        }\n    }\n\n    private void AdjustPlayerHeight()\n    {\n        float targetHeight = normalHeight;\n        float targetSpeed = 0f;\n\n        if (isCrawling)\n        {\n            targetHeight = crawlHeight;\n            targetSpeed = crawlSpeed;\n        }\n        else if (isCrouching)\n        {\n            targetHeight = crouchHeight;\n            targetSpeed = crouchSpeed;\n        }\n\n        // Smoothly adjust character height\n        float currentHeight = characterController.height;\n        characterController.height = Mathf.Lerp(currentHeight, targetHeight, Time.deltaTime * 10f);\n\n        // Adjust camera and controller center\n        if (playerCamera != null)\n        {\n            Vector3 cameraOffset = new Vector3(0, characterController.height / 2, 0);\n            playerCamera.transform.localPosition = Vector3.Lerp(\n                playerCamera.transform.localPosition, \n                cameraOffset, \n                Time.deltaTime * 10f\n            );\n        }\n\n        characterController.center = new Vector3(0, characterController.height / 2, 0);\n    }\n\n    public bool IsCrouching() => isCrouching;\n    public bool IsCrawling() => isCrawling;\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SwarmController\",\n  \"components\": [\n    \"Rigidbody\",\n    \"NavMeshAgent\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"swarmSize\",\n      \"type\": \"int\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"cohesionRadius\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    },\n    {\n      \"name\": \"separationDistance\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    },\n    {\n      \"name\": \"alignmentStrength\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"swarm_movement\",\n      \"trigger\": \"continuously while swarm is active\",\n      \"actions\": [\n        {\n          \"action\": \"calculate average position of nearby swarm members\"\n        },\n        {\n          \"action\": \"move toward average group center\"\n        },\n        {\n          \"action\": \"maintain minimum spacing between individual units\"\n        },\n        {\n          \"action\": \"match movement direction of neighboring units\"\n        }\n      ]\n    },\n    {\n      \"name\": \"avoid_obstacles\",\n      \"trigger\": \"when obstacle is detected in movement path\",\n      \"actions\": [\n        {\n          \"action\": \"adjust individual unit trajectory\"\n        },\n        {\n          \"action\": \"communicate obstacle location to nearby swarm members\"\n        },\n        {\n          \"action\": \"smoothly redirect entire swarm around detected obstacle\"\n        }\n      ]\n    },\n    {\n      \"name\": \"target_pursuit\",\n      \"trigger\": \"when group target is identified\",\n      \"actions\": [\n        {\n          \"action\": \"synchronize movement toward target\"\n        },\n        {\n          \"action\": \"distribute units to surround target area\"\n        },\n        {\n          \"action\": \"maintain cohesive group formation during approach\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class SwarmController : MonoBehaviour\n{\n    [SerializeField] private float cohesionWeight = 1f;\n    [SerializeField] private float separationWeight = 1.5f;\n    [SerializeField] private float alignmentWeight = 1f;\n    [SerializeField] private float maxSpeed = 5f;\n    [SerializeField] private float neighborRadius = 3f;\n\n    private List<SwarmAgent> swarmAgents = new List<SwarmAgent>();\n\n    private void Start()\n    {\n        // Populate swarm agents in the scene\n        swarmAgents.AddRange(FindObjectsOfType<SwarmAgent>());\n    }\n\n    public void RegisterAgent(SwarmAgent agent)\n    {\n        if (!swarmAgents.Contains(agent))\n        {\n            swarmAgents.Add(agent);\n        }\n    }\n\n    public Vector3 CalculateSwarmMovement(SwarmAgent currentAgent)\n    {\n        Vector3 cohesion = CalculateCohesion(currentAgent);\n        Vector3 separation = CalculateSeparation(currentAgent);\n        Vector3 alignment = CalculateAlignment(currentAgent);\n\n        return cohesion * cohesionWeight +\n               separation * separationWeight +\n               alignment * alignmentWeight;\n    }\n\n    private Vector3 CalculateCohesion(SwarmAgent currentAgent)\n    {\n        Vector3 centerMass = Vector3.zero;\n        int neighborCount = 0;\n\n        foreach (SwarmAgent agent in swarmAgents)\n        {\n            if (agent != currentAgent && Vector3.Distance(agent.transform.position, currentAgent.transform.position) <= neighborRadius)\n            {\n                centerMass += agent.transform.position;\n                neighborCount++;\n            }\n        }\n\n        if (neighborCount > 0)\n        {\n            centerMass /= neighborCount;\n            return (centerMass - currentAgent.transform.position).normalized;\n        }\n\n        return Vector3.zero;\n    }\n\n    private Vector3 CalculateSeparation(SwarmAgent currentAgent)\n    {\n        Vector3 separationVector = Vector3.zero;\n\n        foreach (SwarmAgent agent in swarmAgents)\n        {\n            if (agent != currentAgent)\n            {\n                float distance = Vector3.Distance(agent.transform.position, currentAgent.transform.position);\n                if (distance < neighborRadius)\n                {\n                    Vector3 separationDirection = (currentAgent.transform.position - agent.transform.position).normalized;\n                    separationVector += separationDirection / distance;\n                }\n            }\n        }\n\n        return separationVector;\n    }\n\n    private Vector3 CalculateAlignment(SwarmAgent currentAgent)\n    {\n        Vector3 averageVelocity = Vector3.zero;\n        int neighborCount = 0;\n\n        foreach (SwarmAgent agent in swarmAgents)\n        {\n            if (agent != currentAgent && Vector3.Distance(agent.transform.position, currentAgent.transform.position) <= neighborRadius)\n            {\n                averageVelocity += agent.CurrentVelocity;\n                neighborCount++;\n            }\n        }\n\n        if (neighborCount > 0)\n        {\n            averageVelocity /= neighborCount;\n            return averageVelocity.normalized;\n        }\n\n        return Vector3.zero;\n    }\n}\n\npublic class SwarmAgent : MonoBehaviour\n{\n    [SerializeField] private SwarmController swarmController;\n\n    public Vector3 CurrentVelocity { get; private set; }\n\n    private void Start()\n    {\n        if (swarmController == null)\n        {\n            swarmController = FindObjectOfType<SwarmController>();\n        }\n\n        swarmController.RegisterAgent(this);\n    }\n\n    private void Update()\n    {\n        Vector3 swarmMovement = swarmController.CalculateSwarmMovement(this);\n        CurrentVelocity = Vector3.ClampMagnitude(CurrentVelocity + swarmMovement, 5f);\n        transform.position += CurrentVelocity * Time.deltaTime;\n        transform.rotation = Quaternion.LookRotation(CurrentVelocity);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FloatingGem\",\n  \"components\": [\n    \"Rigidbody\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"floatHeight\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"floatSpeed\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"sparkleIntensity\",\n      \"type\": \"float\",\n      \"default\": 0.7\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"hover_movement\",\n      \"trigger\": \"continuously while gem is active\",\n      \"actions\": [\n        {\n          \"action\": \"gently bob up and down in a smooth sine wave motion\"\n        },\n        {\n          \"action\": \"rotate slowly to create subtle shimmer effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"sparkle_effect\",\n      \"trigger\": \"continuously while gem is visible\",\n      \"actions\": [\n        {\n          \"action\": \"emit small, random bursts of light particles\"\n        },\n        {\n          \"action\": \"change particle color between soft white and gem's primary color\"\n        }\n      ]\n    },\n    {\n      \"name\": \"collect_interaction\",\n      \"trigger\": \"when player touches gem\",\n      \"actions\": [\n        {\n          \"action\": \"play pickup sound\"\n        },\n        {\n          \"action\": \"create brief intense sparkle burst\"\n        },\n        {\n          \"action\": \"disappear from game world\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class FloatingSparkleGem : MonoBehaviour\n{\n    [Header(\"Floating Settings\")]\n    [SerializeField] private float floatHeight = 0.5f;\n    [SerializeField] private float floatSpeed = 2f;\n\n    [Header(\"Sparkle Settings\")]\n    [SerializeField] private ParticleSystem sparkleEffect;\n    [SerializeField] private float sparkleIntensity = 1f;\n\n    private Vector3 startPosition;\n    private float timeOffset;\n\n    private void Start()\n    {\n        // Store initial position and generate random time offset for unique floating motion\n        startPosition = transform.position;\n        timeOffset = Random.Range(0f, 2f * Mathf.PI);\n\n        // Ensure sparkle effect is assigned\n        if (sparkleEffect == null)\n        {\n            sparkleEffect = GetComponentInChildren<ParticleSystem>();\n        }\n\n        // Start sparkle effect if available\n        if (sparkleEffect != null)\n        {\n            var main = sparkleEffect.main;\n            main.startLifetime = sparkleIntensity;\n            sparkleEffect.Play();\n        }\n    }\n\n    private void Update()\n    {\n        // Floating motion using sine wave\n        float yOffset = Mathf.Sin((Time.time + timeOffset) * floatSpeed) * floatHeight;\n        transform.position = startPosition + new Vector3(0f, yOffset, 0f);\n\n        // Optional: Rotate slightly for additional visual interest\n        transform.Rotate(Vector3.up, Time.deltaTime * 30f);\n    }\n\n    private void OnDisable()\n    {\n        // Stop sparkle effect when gem is disabled\n        if (sparkleEffect != null)\n        {\n            sparkleEffect.Stop();\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FuelCanister\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"currentFuel\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"maxFuelCapacity\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"refuelRate\",\n      \"type\": \"float\",\n      \"default\": 5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"transfer_fuel\",\n      \"trigger\": \"when vehicle approaches and requests fuel\",\n      \"actions\": [\n        {\n          \"action\": \"gradually transfer fuel from canister to vehicle\"\n        },\n        {\n          \"action\": \"reduce canister's current fuel amount\"\n        },\n        {\n          \"action\": \"stop transfer when canister is empty or vehicle is full\"\n        }\n      ]\n    },\n    {\n      \"name\": \"deplete_warning\",\n      \"trigger\": \"when fuel level drops below 20 percent\",\n      \"actions\": [\n        {\n          \"action\": \"display low fuel warning indicator\"\n        },\n        {\n          \"action\": \"play low fuel audio alert\"\n        }\n      ]\n    },\n    {\n      \"name\": \"refill_canister\",\n      \"trigger\": \"when placed near fuel station or refueling point\",\n      \"actions\": [\n        {\n          \"action\": \"automatically restore fuel to maximum capacity\"\n        },\n        {\n          \"action\": \"play refueling completion sound\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class FuelCanister : MonoBehaviour\n{\n    [SerializeField] private float maxFuelCapacity = 50f;\n    [SerializeField] private float currentFuel;\n    [SerializeField] private float refuelRate = 5f;\n\n    [Header(\"Audio\")]\n    [SerializeField] private AudioClip refuelSound;\n    [SerializeField] private AudioSource audioSource;\n\n    [Header(\"VFX\")]\n    [SerializeField] private ParticleSystem refuelParticles;\n\n    public bool CanRefuel => currentFuel > 0;\n\n    private void Start()\n    {\n        // Initialize fuel to full capacity\n        currentFuel = maxFuelCapacity;\n\n        // Ensure audio source is assigned\n        if (audioSource == null)\n            audioSource = GetComponent<AudioSource>();\n    }\n\n    public float Refuel(float requestedAmount)\n    {\n        // Clamp the refuel amount to available fuel\n        float actualRefuelAmount = Mathf.Min(requestedAmount, currentFuel);\n        \n        if (actualRefuelAmount > 0)\n        {\n            currentFuel -= actualRefuelAmount;\n            \n            // Play refuel sound and particles\n            PlayRefuelEffects();\n        }\n\n        return actualRefuelAmount;\n    }\n\n    private void PlayRefuelEffects()\n    {\n        if (refuelSound != null && audioSource != null)\n        {\n            audioSource.PlayOneShot(refuelSound);\n        }\n\n        if (refuelParticles != null)\n        {\n            refuelParticles.Play();\n        }\n    }\n\n    public void Replenish(float amount)\n    {\n        currentFuel = Mathf.Min(currentFuel + amount, maxFuelCapacity);\n    }\n\n    public float GetRemainingFuel()\n    {\n        return currentFuel;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CompassNavigator\",\n  \"components\": [\n    \"Transform\",\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"targetPosition\",\n      \"type\": \"vector\",\n      \"default\": null\n    },\n    {\n      \"name\": \"compassNeedle\",\n      \"type\": \"gameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"align_compass_to_target\",\n      \"trigger\": \"compass is active and target is set\",\n      \"actions\": [\n        {\n          \"action\": \"calculate direction from current position to target position\"\n        },\n        {\n          \"action\": \"rotate compass needle smoothly toward calculated direction\"\n        },\n        {\n          \"action\": \"ensure compass needle points precisely at target\"\n        }\n      ]\n    },\n    {\n      \"name\": \"update_target_tracking\",\n      \"trigger\": \"target position changes\",\n      \"actions\": [\n        {\n          \"action\": \"recalculate compass needle orientation\"\n        },\n        {\n          \"action\": \"smoothly adjust compass needle rotation\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class CompassPointer : MonoBehaviour\n{\n    [SerializeField] private Transform targetTransform;\n    [SerializeField] private Transform compassNeedle;\n    [SerializeField] private float rotationSmoothing = 5f;\n\n    private void Start()\n    {\n        // Validate required references\n        if (targetTransform == null || compassNeedle == null)\n        {\n            Debug.LogError(\"CompassPointer requires target and needle references!\");\n            enabled = false;\n        }\n    }\n\n    private void Update()\n    {\n        if (targetTransform == null) return;\n\n        // Calculate direction to target\n        Vector3 directionToTarget = targetTransform.position - transform.position;\n        directionToTarget.y = 0; // Flatten to horizontal plane\n\n        // Calculate rotation to face target\n        Quaternion targetRotation = Quaternion.LookRotation(directionToTarget);\n\n        // Smoothly rotate compass needle\n        compassNeedle.rotation = Quaternion.Slerp(\n            compassNeedle.rotation, \n            targetRotation, \n            rotationSmoothing * Time.deltaTime\n        );\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LeverMechanism\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"isActivated\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"activationSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"targetMechanism\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"lever_interaction\",\n      \"trigger\": \"player touches lever\",\n      \"actions\": [\n        {\n          \"action\": \"toggle lever activation state\"\n        },\n        {\n          \"action\": \"play activation sound\"\n        },\n        {\n          \"action\": \"send activation signal to target mechanism\"\n        }\n      ]\n    },\n    {\n      \"name\": \"visual_feedback\",\n      \"trigger\": \"lever changes activation state\",\n      \"actions\": [\n        {\n          \"action\": \"rotate lever to indicate current state\"\n        },\n        {\n          \"action\": \"change lever color based on activation\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.Events;\n\npublic class LeverController : MonoBehaviour\n{\n    [SerializeField] private bool isActivated = false;\n    [SerializeField] private float leverRotationAngle = 45f;\n    [SerializeField] private float rotationSpeed = 5f;\n\n    [SerializeField] private UnityEvent onLeverActivated;\n    [SerializeField] private UnityEvent onLeverDeactivated;\n\n    private Quaternion initialRotation;\n    private Quaternion targetRotation;\n\n    private void Start()\n    {\n        initialRotation = transform.localRotation;\n        targetRotation = Quaternion.Euler(0, 0, leverRotationAngle);\n    }\n\n    private void OnMouseDown()\n    {\n        ToggleLever();\n    }\n\n    public void ToggleLever()\n    {\n        isActivated = !isActivated;\n\n        if (isActivated)\n        {\n            onLeverActivated?.Invoke();\n            targetRotation = Quaternion.Euler(0, 0, leverRotationAngle);\n        }\n        else\n        {\n            onLeverDeactivated?.Invoke();\n            targetRotation = initialRotation;\n        }\n    }\n\n    private void Update()\n    {\n        transform.localRotation = Quaternion.Slerp(transform.localRotation, targetRotation, rotationSpeed * Time.deltaTime);\n    }\n\n    public bool IsActivated => isActivated;\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Minion\",\n  \"components\": [\n    \"NavMeshAgent\",\n    \"Animator\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"leader\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    },\n    {\n      \"name\": \"followDistance\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"maxFollowRange\",\n      \"type\": \"float\",\n      \"default\": 10.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"follow_leader\",\n      \"trigger\": \"when leader is detected in scene\",\n      \"actions\": [\n        {\n          \"action\": \"calculate distance to leader\"\n        },\n        {\n          \"action\": \"if distance is greater than follow distance, move toward leader\"\n        },\n        {\n          \"action\": \"if distance is beyond max follow range, teleport closer to leader\"\n        }\n      ]\n    },\n    {\n      \"name\": \"idle_behavior\",\n      \"trigger\": \"when no leader is present\",\n      \"actions\": [\n        {\n          \"action\": \"stop moving\"\n        },\n        {\n          \"action\": \"play idle animation\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.AI;\n\npublic class MinionFollower : MonoBehaviour\n{\n    [SerializeField] private Transform leader;\n    [SerializeField] private float followDistance = 3f;\n    [SerializeField] private float maxFollowSpeed = 4f;\n    [SerializeField] private float minFollowSpeed = 1f;\n\n    private NavMeshAgent navMeshAgent;\n\n    private void Start()\n    {\n        // Get the NavMeshAgent component\n        navMeshAgent = GetComponent<NavMeshAgent>();\n\n        // Validate leader reference\n        if (leader == null)\n        {\n            Debug.LogWarning(\"No leader assigned to minion!\");\n        }\n    }\n\n    private void Update()\n    {\n        if (leader == null) return;\n\n        // Calculate distance to leader\n        float distanceToLeader = Vector3.Distance(transform.position, leader.position);\n\n        // Adjust navigation based on distance\n        if (distanceToLeader > followDistance)\n        {\n            navMeshAgent.SetDestination(leader.position);\n            AdjustSpeed(distanceToLeader);\n        }\n        else\n        {\n            // Stop moving when close to leader\n            navMeshAgent.SetDestination(transform.position);\n        }\n    }\n\n    private void AdjustSpeed(float distance)\n    {\n        // Dynamically adjust speed based on distance\n        float speedFactor = Mathf.Clamp(distance / followDistance, 0f, 1f);\n        navMeshAgent.speed = Mathf.Lerp(minFollowSpeed, maxFollowSpeed, speedFactor);\n    }\n\n    public void SetLeader(Transform newLeader)\n    {\n        leader = newLeader;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MinecartController\",\n  \"components\": [\n    \"RailTracker\",\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"movementSpeed\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"railDirection\",\n      \"type\": \"string\",\n      \"default\": \"forward\"\n    },\n    {\n      \"name\": \"maxTrackLength\",\n      \"type\": \"float\",\n      \"default\": 100\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"follow_rail_track\",\n      \"trigger\": \"when minecart is placed on rail track\",\n      \"actions\": [\n        {\n          \"action\": \"start moving along connected rail segments\"\n        },\n        {\n          \"action\": \"maintain constant speed on track\"\n        },\n        {\n          \"action\": \"play rolling sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"change_direction\",\n      \"trigger\": \"when rail track changes orientation\",\n      \"actions\": [\n        {\n          \"action\": \"smoothly adjust movement direction\"\n        },\n        {\n          \"action\": \"rotate minecart to match track angle\"\n        }\n      ]\n    },\n    {\n      \"name\": \"stop_at_end_of_track\",\n      \"trigger\": \"when minecart reaches end of rail segment\",\n      \"actions\": [\n        {\n          \"action\": \"gradually reduce speed\"\n        },\n        {\n          \"action\": \"come to complete stop\"\n        },\n        {\n          \"action\": \"play stopping sound effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class MinecartController : MonoBehaviour\n{\n    [SerializeField] private float moveSpeed = 5f;\n    [SerializeField] private Transform[] railPoints;\n    [SerializeField] private float waypointThreshold = 0.1f;\n\n    private int currentWaypointIndex = 0;\n    private Rigidbody rb;\n\n    private void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        \n        if (railPoints == null || railPoints.Length == 0)\n        {\n            Debug.LogError(\"No rail points assigned to minecart!\");\n            enabled = false;\n        }\n    }\n\n    private void FixedUpdate()\n    {\n        if (railPoints == null || railPoints.Length == 0) return;\n\n        MoveAlongRail();\n    }\n\n    private void MoveAlongRail()\n    {\n        if (currentWaypointIndex >= railPoints.Length) return;\n\n        Vector3 targetPosition = railPoints[currentWaypointIndex].position;\n        Vector3 moveDirection = (targetPosition - transform.position).normalized;\n\n        rb.MovePosition(rb.position + moveDirection * moveSpeed * Time.fixedDeltaTime);\n\n        if (Vector3.Distance(transform.position, targetPosition) < waypointThreshold)\n        {\n            currentWaypointIndex++;\n            \n            if (currentWaypointIndex >= railPoints.Length)\n            {\n                // Optional: Reset or stop movement\n                currentWaypointIndex = 0;\n            }\n        }\n\n        // Optional: Rotate minecart to face movement direction\n        transform.rotation = Quaternion.LookRotation(moveDirection);\n    }\n\n    public void ResetPath()\n    {\n        currentWaypointIndex = 0;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Shotgun\",\n  \"components\": [\n    \"Weapon\",\n    \"AudioSource\",\n    \"ParticleSystem\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"damage\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"pelletCount\",\n      \"type\": \"int\",\n      \"default\": 8\n    },\n    {\n      \"name\": \"spreadAngle\",\n      \"type\": \"float\",\n      \"default\": 15\n    },\n    {\n      \"name\": \"range\",\n      \"type\": \"float\",\n      \"default\": 20\n    },\n    {\n      \"name\": \"reloadTime\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"fire_weapon\",\n      \"trigger\": \"player presses fire button\",\n      \"actions\": [\n        {\n          \"action\": \"create multiple projectile pellets in a cone-like spread pattern\"\n        },\n        {\n          \"action\": \"apply random directional variance to each pellet\"\n        },\n        {\n          \"action\": \"play loud gunshot sound effect\"\n        },\n        {\n          \"action\": \"generate muzzle flash particle effect\"\n        },\n        {\n          \"action\": \"reduce ammo count\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reload_weapon\",\n      \"trigger\": \"ammo is empty or player requests reload\",\n      \"actions\": [\n        {\n          \"action\": \"disable firing capability\"\n        },\n        {\n          \"action\": \"play reload animation\"\n        },\n        {\n          \"action\": \"wait for reload duration\"\n        },\n        {\n          \"action\": \"reset ammo to full capacity\"\n        },\n        {\n          \"action\": \"re-enable firing\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class ShotgunController : MonoBehaviour\n{\n    [SerializeField] private GameObject bulletPrefab;\n    [SerializeField] private Transform firePoint;\n    [SerializeField] private float shotgunRange = 20f;\n    [SerializeField] private int pelletCount = 8;\n    [SerializeField] private float spreadAngle = 15f;\n    [SerializeField] private float bulletSpeed = 25f;\n    [SerializeField] private float fireRate = 0.5f;\n\n    private float nextFireTime;\n\n    private void Update()\n    {\n        if (Input.GetButtonDown(\"Fire1\") && Time.time >= nextFireTime)\n        {\n            FireShotgun();\n            nextFireTime = Time.time + fireRate;\n        }\n    }\n\n    private void FireShotgun()\n    {\n        if (bulletPrefab == null || firePoint == null)\n        {\n            Debug.LogWarning(\"Shotgun configuration is missing!\");\n            return;\n        }\n\n        for (int i = 0; i < pelletCount; i++)\n        {\n            Vector3 spreadDirection = CalculateSpreadDirection();\n            GameObject pellet = Instantiate(bulletPrefab, firePoint.position, Quaternion.LookRotation(spreadDirection));\n            \n            Rigidbody pelletRb = pellet.GetComponent<Rigidbody>();\n            if (pelletRb != null)\n            {\n                pelletRb.velocity = spreadDirection * bulletSpeed;\n            }\n\n            Destroy(pellet, shotgunRange / bulletSpeed);\n        }\n    }\n\n    private Vector3 CalculateSpreadDirection()\n    {\n        Vector3 baseDirection = firePoint.forward;\n        \n        float randomHorizontalSpread = Random.Range(-spreadAngle, spreadAngle);\n        float randomVerticalSpread = Random.Range(-spreadAngle, spreadAngle);\n\n        Quaternion horizontalRotation = Quaternion.AngleAxis(randomHorizontalSpread, firePoint.up);\n        Quaternion verticalRotation = Quaternion.AngleAxis(randomVerticalSpread, firePoint.right);\n\n        return horizontalRotation * verticalRotation * baseDirection;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"FootstepSoundController\",\n  \"components\": [\n    \"AudioSource\",\n    \"CharacterController\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"grassSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"woodSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"stoneSound\",\n      \"type\": \"AudioClip\",\n      \"default\": null\n    },\n    {\n      \"name\": \"stepVolume\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"stepInterval\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"play_surface_footstep\",\n      \"trigger\": \"character moves and touches ground surface\",\n      \"actions\": [\n        {\n          \"action\": \"detect current surface material\"\n        },\n        {\n          \"action\": \"select matching sound based on surface type\"\n        },\n        {\n          \"action\": \"play footstep sound at current volume\"\n        },\n        {\n          \"action\": \"add small random pitch variation to sound\"\n        }\n      ]\n    },\n    {\n      \"name\": \"adjust_footstep_frequency\",\n      \"trigger\": \"character changes movement speed\",\n      \"actions\": [\n        {\n          \"action\": \"modify step interval based on current speed\"\n        },\n        {\n          \"action\": \"adjust footstep sound volume proportionally\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class FootstepSoundController : MonoBehaviour\n{\n    [System.Serializable]\n    public class SurfaceAudioMapping\n    {\n        public PhysicMaterial surfaceMaterial;\n        public AudioClip[] footstepSounds;\n    }\n\n    [SerializeField] private SurfaceAudioMapping[] surfaceMappings;\n    [SerializeField] private AudioSource audioSource;\n    [SerializeField] private float stepInterval = 0.5f;\n    [SerializeField] private float movementThreshold = 0.1f;\n\n    private CharacterController characterController;\n    private float stepTimer;\n    private Vector3 lastPosition;\n\n    private void Start()\n    {\n        characterController = GetComponent<CharacterController>();\n        \n        if (audioSource == null)\n            audioSource = GetComponent<AudioSource>();\n\n        if (audioSource == null)\n            audioSource = gameObject.AddComponent<AudioSource>();\n    }\n\n    private void Update()\n    {\n        if (IsMoving())\n        {\n            stepTimer += Time.deltaTime;\n\n            if (stepTimer >= stepInterval)\n            {\n                PlayFootstepSound();\n                stepTimer = 0f;\n            }\n        }\n        else\n        {\n            stepTimer = 0f;\n        }\n\n        lastPosition = transform.position;\n    }\n\n    private bool IsMoving()\n    {\n        return Vector3.Distance(transform.position, lastPosition) > movementThreshold;\n    }\n\n    private void PlayFootstepSound()\n    {\n        RaycastHit hit;\n        if (Physics.Raycast(transform.position, Vector3.down, out hit, 2f))\n        {\n            SurfaceAudioMapping matchedMapping = FindSurfaceMapping(hit.collider.sharedMaterial);\n            \n            if (matchedMapping != null && matchedMapping.footstepSounds.Length > 0)\n            {\n                AudioClip randomStepSound = matchedMapping.footstepSounds[Random.Range(0, matchedMapping.footstepSounds.Length)];\n                audioSource.PlayOneShot(randomStepSound);\n            }\n        }\n    }\n\n    private SurfaceAudioMapping FindSurfaceMapping(PhysicMaterial material)\n    {\n        foreach (SurfaceAudioMapping mapping in surfaceMappings)\n        {\n            if (mapping.surfaceMaterial == material)\n            {\n                return mapping;\n            }\n        }\n        return null;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"EnemyRetreatBehavior\",\n  \"components\": [\n    \"Health\",\n    \"Movement\",\n    \"AIController\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"currentHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"maxHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"retreatThreshold\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"retreatSpeed\",\n      \"type\": \"float\",\n      \"default\": 3\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"health_check_retreat\",\n      \"trigger\": \"when current health drops below retreat threshold percentage\",\n      \"actions\": [\n        {\n          \"action\": \"start moving away from current combat position\"\n        },\n        {\n          \"action\": \"reduce movement speed to retreat speed\"\n        },\n        {\n          \"action\": \"seek nearest safe location or cover\"\n        }\n      ]\n    },\n    {\n      \"name\": \"recovery_behavior\",\n      \"trigger\": \"when health increases above retreat threshold\",\n      \"actions\": [\n        {\n          \"action\": \"resume normal movement speed\"\n        },\n        {\n          \"action\": \"return to previous combat position\"\n        },\n        {\n          \"action\": \"re-engage with original target\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class EnemyRetreat : MonoBehaviour\n{\n    [SerializeField] private float maxHealth = 100f;\n    [SerializeField] private float currentHealth;\n    [SerializeField] private float retreatThreshold = 0.3f;\n    [SerializeField] private float retreatSpeed = 3f;\n    [SerializeField] private Transform retreatPoint;\n\n    private bool isRetreating = false;\n\n    private void Start()\n    {\n        currentHealth = maxHealth;\n    }\n\n    public void TakeDamage(float damageAmount)\n    {\n        currentHealth -= damageAmount;\n        CheckRetreatCondition();\n    }\n\n    private void CheckRetreatCondition()\n    {\n        if (currentHealth / maxHealth <= retreatThreshold && !isRetreating)\n        {\n            StartRetreat();\n        }\n    }\n\n    private void StartRetreat()\n    {\n        isRetreating = true;\n        if (retreatPoint == null)\n        {\n            Debug.LogWarning(\"No retreat point set for enemy!\");\n            return;\n        }\n    }\n\n    private void Update()\n    {\n        if (isRetreating)\n        {\n            transform.position = Vector3.MoveTowards(\n                transform.position, \n                retreatPoint.position, \n                retreatSpeed * Time.deltaTime\n            );\n\n            if (Vector3.Distance(transform.position, retreatPoint.position) < 0.1f)\n            {\n                CompleteRetreat();\n            }\n        }\n    }\n\n    private void CompleteRetreat()\n    {\n        isRetreating = false;\n        gameObject.SetActive(false);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"CoinController\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 180\n    },\n    {\n      \"name\": \"scoreValue\",\n      \"type\": \"int\",\n      \"default\": 10\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"continuous_rotation\",\n      \"trigger\": \"every frame\",\n      \"actions\": [\n        {\n          \"action\": \"rotate around vertical axis at constant speed\"\n        }\n      ]\n    },\n    {\n      \"name\": \"player_collection\",\n      \"trigger\": \"when player touches coin\",\n      \"actions\": [\n        {\n          \"action\": \"increase player's total score by coin's score value\"\n        },\n        {\n          \"action\": \"play coin collection sound\"\n        },\n        {\n          \"action\": \"remove coin from game world\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class CoinController : MonoBehaviour\n{\n    [SerializeField] private float rotationSpeed = 100f;\n    [SerializeField] private int scoreValue = 10;\n    [SerializeField] private AudioClip collectSound;\n\n    private void Update()\n    {\n        // Rotate coin continuously\n        transform.Rotate(Vector3.up, rotationSpeed * Time.deltaTime);\n    }\n\n    private void OnTriggerEnter(Collider other)\n    {\n        // Check if player collected the coin\n        if (other.CompareTag(\"Player\"))\n        {\n            // Add score to player\n            GameManager.Instance.AddScore(scoreValue);\n\n            // Play collect sound if available\n            if (collectSound != null)\n            {\n                AudioSource.PlayClipAtPoint(collectSound, transform.position);\n            }\n\n            // Destroy coin object\n            Destroy(gameObject);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ColorMatchPuzzleBlock\",\n  \"components\": [\n    \"Renderer\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"blockColor\",\n      \"type\": \"string\",\n      \"default\": \"red\"\n    },\n    {\n      \"name\": \"isCorrectlyPlaced\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"puzzleTargetColor\",\n      \"type\": \"string\",\n      \"default\": \"red\"\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_block_placement\",\n      \"trigger\": \"when block is placed in puzzle area\",\n      \"actions\": [\n        {\n          \"action\": \"check if block color matches target color\"\n        },\n        {\n          \"action\": \"update block placement status\"\n        },\n        {\n          \"action\": \"play sound effect based on correct or incorrect placement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"highlight_block_selection\",\n      \"trigger\": \"when player hovers over block\",\n      \"actions\": [\n        {\n          \"action\": \"show selection outline around block\"\n        },\n        {\n          \"action\": \"display current block color information\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_puzzle_block\",\n      \"trigger\": \"when puzzle is restarted or block is incorrectly placed\",\n      \"actions\": [\n        {\n          \"action\": \"return block to original starting position\"\n        },\n        {\n          \"action\": \"reset block placement status\"\n        },\n        {\n          \"action\": \"reset block color to default\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class ColorMatchPuzzleBlock : MonoBehaviour\n{\n    [SerializeField] private SpriteRenderer blockRenderer;\n    [SerializeField] private Color[] availableColors;\n    [SerializeField] private float matchTolerance = 0.1f;\n\n    private Color currentColor;\n    private bool isSelected = false;\n\n    public enum BlockState\n    {\n        Idle,\n        Selected,\n        Matched\n    }\n\n    private BlockState currentState = BlockState.Idle;\n\n    private void Start()\n    {\n        // Randomly assign initial color if not set\n        if (blockRenderer == null)\n            blockRenderer = GetComponent<SpriteRenderer>();\n\n        if (availableColors.Length > 0)\n            SetRandomColor();\n    }\n\n    public void SetRandomColor()\n    {\n        currentColor = availableColors[Random.Range(0, availableColors.Length)];\n        blockRenderer.color = currentColor;\n    }\n\n    public void OnBlockSelected()\n    {\n        if (currentState != BlockState.Matched)\n        {\n            isSelected = true;\n            currentState = BlockState.Selected;\n            transform.localScale = Vector3.one * 1.2f; // Visual feedback\n        }\n    }\n\n    public bool CheckColorMatch(Color targetColor)\n    {\n        bool isMatch = ColorComparer.AreColorsSimilar(currentColor, targetColor, matchTolerance);\n        \n        if (isMatch)\n        {\n            currentState = BlockState.Matched;\n            blockRenderer.color = Color.green; // Highlight matched block\n        }\n\n        return isMatch;\n    }\n\n    public void Deselect()\n    {\n        isSelected = false;\n        currentState = BlockState.Idle;\n        transform.localScale = Vector3.one; // Reset scale\n    }\n\n    private void OnMouseDown()\n    {\n        OnBlockSelected();\n    }\n\n    // Static utility for color comparison\n    private static class ColorComparer\n    {\n        public static bool AreColorsSimilar(Color color1, Color color2, float tolerance)\n        {\n            return Mathf.Abs(color1.r - color2.r) <= tolerance &&\n                   Mathf.Abs(color1.g - color2.g) <= tolerance &&\n                   Mathf.Abs(color1.b - color2.b) <= tolerance;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ClimbingSystem\",\n  \"components\": [\n    \"CharacterController\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"climbSpeed\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"climbableLayerMask\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isCurrentlyClimbing\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_climbable_surface\",\n      \"trigger\": \"character touches a surface marked as climbable\",\n      \"actions\": [\n        {\n          \"action\": \"enable climbing mode\"\n        },\n        {\n          \"action\": \"adjust character orientation to surface normal\"\n        },\n        {\n          \"action\": \"disable standard gravity\"\n        }\n      ]\n    },\n    {\n      \"name\": \"climbing_movement\",\n      \"trigger\": \"player provides vertical or horizontal input while on climbable surface\",\n      \"actions\": [\n        {\n          \"action\": \"move character along surface in direction of input\"\n        },\n        {\n          \"action\": \"maintain character's attachment to surface\"\n        }\n      ]\n    },\n    {\n      \"name\": \"exit_climbing\",\n      \"trigger\": \"player moves away from climbable surface or presses jump button\",\n      \"actions\": [\n        {\n          \"action\": \"disable climbing mode\"\n        },\n        {\n          \"action\": \"restore standard gravity\"\n        },\n        {\n          \"action\": \"launch character slightly away from surface\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class ClimbingSurfaceController : MonoBehaviour\n{\n    [SerializeField] private float climbSpeed = 3f;\n    [SerializeField] private float verticalClimbSpeed = 2f;\n    [SerializeField] private LayerMask climbableSurfaceMask;\n\n    private Rigidbody rb;\n    private bool isClimbing = false;\n    private Vector3 surfaceNormal;\n\n    private void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        if (rb == null)\n        {\n            Debug.LogError(\"Rigidbody component required for climbing!\");\n        }\n    }\n\n    private void Update()\n    {\n        CheckClimbingSurface();\n        HandleClimbingInput();\n    }\n\n    private void CheckClimbingSurface()\n    {\n        RaycastHit hit;\n        if (Physics.Raycast(transform.position, transform.forward, out hit, 1f, climbableSurfaceMask))\n        {\n            isClimbing = true;\n            surfaceNormal = hit.normal;\n        }\n        else\n        {\n            isClimbing = false;\n        }\n    }\n\n    private void HandleClimbingInput()\n    {\n        if (!isClimbing) return;\n\n        float verticalInput = Input.GetAxis(\"Vertical\");\n        float horizontalInput = Input.GetAxis(\"Horizontal\");\n\n        Vector3 climbMovement = transform.up * verticalInput * verticalClimbSpeed +\n                                transform.right * horizontalInput * climbSpeed;\n\n        if (rb != null)\n        {\n            rb.velocity = Vector3.ProjectOnPlane(climbMovement, surfaceNormal);\n        }\n    }\n\n    private void FixedUpdate()\n    {\n        if (isClimbing)\n        {\n            // Additional physics-based climbing adjustments\n            AlignToSurface();\n        }\n    }\n\n    private void AlignToSurface()\n    {\n        Quaternion targetRotation = Quaternion.LookRotation(-surfaceNormal, transform.up);\n        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, Time.deltaTime * 5f);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"RandomFlickerLight\",\n  \"components\": [\n    \"Light\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"minIntensity\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"maxIntensity\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    },\n    {\n      \"name\": \"flickerFrequency\",\n      \"type\": \"float\",\n      \"default\": 2.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"random_flicker\",\n      \"trigger\": \"continuously while light is active\",\n      \"actions\": [\n        {\n          \"action\": \"randomly change light intensity within defined range\"\n        },\n        {\n          \"action\": \"pause for a random duration between flicker changes\"\n        },\n        {\n          \"action\": \"smoothly transition light intensity to create flickering effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class LightFlicker : MonoBehaviour\n{\n    [SerializeField] private Light targetLight;\n    [SerializeField] private float minIntensity = 0.5f;\n    [SerializeField] private float maxIntensity = 1.5f;\n    [SerializeField] private float flickerSpeed = 5f;\n\n    private float originalIntensity;\n    private float randomTarget;\n    private float currentFlickerTime;\n\n    private void Start()\n    {\n        // If no light is assigned, try to get the light component on this GameObject\n        if (targetLight == null)\n            targetLight = GetComponent<Light>();\n\n        // Cache the original light intensity\n        if (targetLight != null)\n            originalIntensity = targetLight.intensity;\n        else\n            Debug.LogWarning(\"No light component found for flickering.\");\n    }\n\n    private void Update()\n    {\n        if (targetLight == null) return;\n\n        // Increment flicker timer\n        currentFlickerTime += Time.deltaTime * flickerSpeed;\n\n        // Smoothly interpolate between current and target intensity\n        targetLight.intensity = Mathf.Lerp(targetLight.intensity, randomTarget, currentFlickerTime);\n\n        // When we reach close to the target, set a new random target\n        if (Mathf.Abs(targetLight.intensity - randomTarget) < 0.01f)\n        {\n            randomTarget = Random.Range(minIntensity, maxIntensity);\n            currentFlickerTime = 0f;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PlayerJumpController\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"maxJumps\",\n      \"type\": \"int\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"jumpForce\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"currentJumpCount\",\n      \"type\": \"int\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"isGrounded\",\n      \"type\": \"bool\",\n      \"default\": false\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"ground_detection\",\n      \"trigger\": \"player touches ground surface\",\n      \"actions\": [\n        {\n          \"action\": \"reset jump count to zero\"\n        },\n        {\n          \"action\": \"mark player as grounded\"\n        }\n      ]\n    },\n    {\n      \"name\": \"double_jump\",\n      \"trigger\": \"jump button is pressed and current jump count is less than max jumps\",\n      \"actions\": [\n        {\n          \"action\": \"apply upward jumping force\"\n        },\n        {\n          \"action\": \"increment current jump count\"\n        },\n        {\n          \"action\": \"mark player as not grounded\"\n        }\n      ]\n    },\n    {\n      \"name\": \"prevent_extra_jumps\",\n      \"trigger\": \"jump button is pressed and current jump count equals max jumps\",\n      \"actions\": [\n        {\n          \"action\": \"ignore jump input\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class DoubleJumpController : MonoBehaviour\n{\n    [SerializeField] private float jumpForce = 10f;\n    [SerializeField] private float groundCheckDistance = 0.1f;\n    [SerializeField] private LayerMask groundLayer;\n\n    private Rigidbody2D rb;\n    private bool isGrounded;\n    private bool canDoubleJump;\n    private int remainingJumps;\n\n    private void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        if (rb == null)\n        {\n            Debug.LogError(\"Rigidbody2D component not found on player!\");\n        }\n    }\n\n    private void Update()\n    {\n        // Check if player is grounded\n        isGrounded = Physics2D.Raycast(transform.position, Vector2.down, groundCheckDistance, groundLayer);\n\n        // Reset jumps when touching ground\n        if (isGrounded)\n        {\n            remainingJumps = 2;\n            canDoubleJump = false;\n        }\n\n        // Jump input handling\n        if (Input.GetButtonDown(\"Jump\"))\n        {\n            PerformJump();\n        }\n    }\n\n    private void PerformJump()\n    {\n        // First jump or ground jump\n        if (isGrounded)\n        {\n            Jump();\n            canDoubleJump = true;\n        }\n        // Double jump\n        else if (canDoubleJump && remainingJumps > 0)\n        {\n            Jump();\n            canDoubleJump = false;\n            remainingJumps--;\n        }\n    }\n\n    private void Jump()\n    {\n        rb.velocity = new Vector2(rb.velocity.x, 0f); // Reset vertical velocity\n        rb.AddForce(Vector2.up * jumpForce, ForceMode2D.Impulse);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Campfire\",\n  \"components\": [\n    \"Collider\",\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"healAmount\",\n      \"type\": \"float\",\n      \"default\": 5\n    },\n    {\n      \"name\": \"healInterval\",\n      \"type\": \"float\",\n      \"default\": 2\n    },\n    {\n      \"name\": \"healRadius\",\n      \"type\": \"float\",\n      \"default\": 3\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"heal_nearby_players\",\n      \"trigger\": \"when player is within healing radius of campfire\",\n      \"actions\": [\n        {\n          \"action\": \"gradually restore player health over time\"\n        },\n        {\n          \"action\": \"play healing particle effect\"\n        },\n        {\n          \"action\": \"emit soft warm glow around campfire\"\n        }\n      ]\n    },\n    {\n      \"name\": \"extinguish_campfire\",\n      \"trigger\": \"when water or rain touches campfire\",\n      \"actions\": [\n        {\n          \"action\": \"stop healing effect\"\n        },\n        {\n          \"action\": \"reduce light intensity\"\n        },\n        {\n          \"action\": \"change campfire visual state to wet and inactive\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class Campfire : MonoBehaviour\n{\n    [SerializeField] private float healingRadius = 3f;\n    [SerializeField] private float healPerSecond = 5f;\n    [SerializeField] private float healInterval = 1f;\n\n    private float healTimer = 0f;\n\n    private void Update()\n    {\n        // Increment heal timer\n        healTimer += Time.deltaTime;\n\n        // Check if it's time to heal\n        if (healTimer >= healInterval)\n        {\n            HealNearbyPlayers();\n            healTimer = 0f;\n        }\n    }\n\n    private void HealNearbyPlayers()\n    {\n        // Find all colliders within healing radius\n        Collider[] colliders = Physics.OverlapSphere(transform.position, healingRadius);\n\n        foreach (Collider collider in colliders)\n        {\n            // Try to get player health component\n            PlayerHealth playerHealth = collider.GetComponent<PlayerHealth>();\n\n            // Heal player if component exists\n            if (playerHealth != null)\n            {\n                playerHealth.Heal(healPerSecond);\n            }\n        }\n    }\n\n    // Optional: Visualize healing radius in editor\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(transform.position, healingRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"SpikeTrap\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"damage\",\n      \"type\": \"float\",\n      \"default\": 25\n    },\n    {\n      \"name\": \"damageInterval\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"isActive\",\n      \"type\": \"bool\",\n      \"default\": true\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"damage_on_contact\",\n      \"trigger\": \"when another object enters the trap's collision area\",\n      \"actions\": [\n        {\n          \"action\": \"check if the object is a damageable entity\"\n        },\n        {\n          \"action\": \"apply damage to the contacted object\"\n        },\n        {\n          \"action\": \"play sharp stabbing sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"periodic_damage\",\n      \"trigger\": \"while an object remains inside the trap's collision area\",\n      \"actions\": [\n        {\n          \"action\": \"repeatedly inflict damage at set time intervals\"\n        },\n        {\n          \"action\": \"prevent instant repeated damage\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class SpikeTrap : MonoBehaviour\n{\n    [SerializeField] private float damageAmount = 10f;\n    [SerializeField] private float damageInterval = 0.5f;\n\n    private float lastDamageTime;\n\n    private void OnTriggerStay2D(Collider2D other)\n    {\n        // Check if the colliding object is a player or damageable entity\n        IDamageable damageable = other.GetComponent<IDamageable>();\n        if (damageable != null)\n        {\n            // Ensure damage is only applied at specified intervals\n            if (Time.time - lastDamageTime >= damageInterval)\n            {\n                damageable.TakeDamage(damageAmount);\n                lastDamageTime = Time.time;\n            }\n        }\n    }\n}\n\n// Optional interface for damage handling\npublic interface IDamageable\n{\n    void TakeDamage(float amount);\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"ItemTooltip\",\n  \"components\": [\n    \"BoxCollider\",\n    \"Canvas\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"tooltipText\",\n      \"type\": \"string\",\n      \"default\": \"\"\n    },\n    {\n      \"name\": \"tooltipDelay\",\n      \"type\": \"float\",\n      \"default\": 0.5\n    },\n    {\n      \"name\": \"tooltipPanel\",\n      \"type\": \"GameObject\",\n      \"default\": null\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"show_tooltip\",\n      \"trigger\": \"mouse cursor enters item's collider area\",\n      \"actions\": [\n        {\n          \"action\": \"wait for specified tooltip delay\"\n        },\n        {\n          \"action\": \"display tooltip panel with item description\"\n        },\n        {\n          \"action\": \"position tooltip near mouse cursor\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hide_tooltip\",\n      \"trigger\": \"mouse cursor leaves item's collider area\",\n      \"actions\": [\n        {\n          \"action\": \"immediately hide tooltip panel\"\n        },\n        {\n          \"action\": \"reset tooltip delay timer\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.EventSystems;\nusing TMPro;\n\npublic class ItemTooltipHandler : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler\n{\n    [SerializeField] private TextMeshProUGUI tooltipText;\n    [SerializeField] private GameObject tooltipPanel;\n    \n    [Header(\"Tooltip Configuration\")]\n    [SerializeField] private string itemDescription = \"Default item description\";\n    [SerializeField] private float tooltipDelay = 0.5f;\n\n    private float tooltipTimer;\n    private bool isHovering;\n\n    private void Start()\n    {\n        // Ensure tooltip is hidden on start\n        if (tooltipPanel != null)\n            tooltipPanel.SetActive(false);\n    }\n\n    private void Update()\n    {\n        // Handle tooltip display with delay\n        if (isHovering)\n        {\n            tooltipTimer += Time.deltaTime;\n\n            if (tooltipTimer >= tooltipDelay)\n            {\n                ShowTooltip();\n            }\n        }\n    }\n\n    public void OnPointerEnter(PointerEventData eventData)\n    {\n        isHovering = true;\n        tooltipTimer = 0f;\n    }\n\n    public void OnPointerExit(PointerEventData eventData)\n    {\n        isHovering = false;\n        tooltipTimer = 0f;\n        HideTooltip();\n    }\n\n    private void ShowTooltip()\n    {\n        if (tooltipPanel != null && tooltipText != null)\n        {\n            tooltipText.text = itemDescription;\n            tooltipPanel.SetActive(true);\n        }\n    }\n\n    private void HideTooltip()\n    {\n        if (tooltipPanel != null)\n        {\n            tooltipPanel.SetActive(false);\n        }\n    }\n\n    // Optional method to dynamically set tooltip text\n    public void SetTooltipText(string newDescription)\n    {\n        itemDescription = newDescription;\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"DialogueNPC\",\n  \"components\": [\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"dialogueRange\",\n      \"type\": \"float\",\n      \"default\": 3.0\n    },\n    {\n      \"name\": \"currentDialogueState\",\n      \"type\": \"string\",\n      \"default\": \"neutral\"\n    },\n    {\n      \"name\": \"dialogueOptions\",\n      \"type\": \"string[]\",\n      \"default\": [\n        \"Hello\",\n        \"Tell me more\",\n        \"Goodbye\"\n      ]\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"initiate_dialogue\",\n      \"trigger\": \"player enters interaction range\",\n      \"actions\": [\n        {\n          \"action\": \"display first dialogue option\"\n        },\n        {\n          \"action\": \"highlight interaction prompt\"\n        },\n        {\n          \"action\": \"pause player movement\"\n        }\n      ]\n    },\n    {\n      \"name\": \"select_dialogue_response\",\n      \"trigger\": \"player selects dialogue option\",\n      \"actions\": [\n        {\n          \"action\": \"change NPC's emotional state based on selected option\"\n        },\n        {\n          \"action\": \"play corresponding voice line\"\n        },\n        {\n          \"action\": \"show next set of dialogue choices\"\n        }\n      ]\n    },\n    {\n      \"name\": \"end_conversation\",\n      \"trigger\": \"player chooses goodbye option or moves away\",\n      \"actions\": [\n        {\n          \"action\": \"reset NPC dialogue state\"\n        },\n        {\n          \"action\": \"resume player movement\"\n        },\n        {\n          \"action\": \"hide dialogue interface\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\n\npublic class NPCDialogue : MonoBehaviour\n{\n    [SerializeField] private string npcName = \"Unnamed NPC\";\n    [SerializeField] private List<DialogueOption> dialogueOptions = new List<DialogueOption>();\n    \n    [SerializeField] private float interactionRadius = 2f;\n    [SerializeField] private LayerMask playerLayer;\n\n    private bool isInRange = false;\n    private int currentDialogueIndex = 0;\n\n    [System.Serializable]\n    public class DialogueOption\n    {\n        public string dialogueText;\n        public bool isEndDialogue;\n        public UnityEngine.Events.UnityEvent onSelectAction;\n    }\n\n    private void Update()\n    {\n        CheckPlayerProximity();\n        HandleDialogueInput();\n    }\n\n    private void CheckPlayerProximity()\n    {\n        Collider[] hitColliders = Physics.OverlapSphere(transform.position, interactionRadius, playerLayer);\n        isInRange = hitColliders.Length > 0;\n    }\n\n    private void HandleDialogueInput()\n    {\n        if (isInRange && Input.GetKeyDown(KeyCode.E))\n        {\n            DisplayDialogue();\n        }\n    }\n\n    private void DisplayDialogue()\n    {\n        if (currentDialogueIndex < dialogueOptions.Count)\n        {\n            DialogueOption currentOption = dialogueOptions[currentDialogueIndex];\n            \n            Debug.Log($\"{npcName}: {currentOption.dialogueText}\");\n            \n            currentOption.onSelectAction?.Invoke();\n\n            if (currentOption.isEndDialogue)\n            {\n                ResetDialogue();\n            }\n            else\n            {\n                currentDialogueIndex++;\n            }\n        }\n        else\n        {\n            ResetDialogue();\n        }\n    }\n\n    private void ResetDialogue()\n    {\n        currentDialogueIndex = 0;\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.yellow;\n        Gizmos.DrawWireSphere(transform.position, interactionRadius);\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"Motorcycle\",\n  \"components\": [\n    \"Rigidbody\",\n    \"Collider\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"turnSensitivity\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    },\n    {\n      \"name\": \"maxLeanAngle\",\n      \"type\": \"float\",\n      \"default\": 45\n    },\n    {\n      \"name\": \"currentSpeed\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"maxSpeed\",\n      \"type\": \"float\",\n      \"default\": 100\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"steer_with_lean\",\n      \"trigger\": \"player is turning motorcycle's handlebars\",\n      \"actions\": [\n        {\n          \"action\": \"tilt motorcycle body in direction of turn\"\n        },\n        {\n          \"action\": \"adjust lean angle based on turning intensity\"\n        },\n        {\n          \"action\": \"limit lean angle to prevent tipping\"\n        }\n      ]\n    },\n    {\n      \"name\": \"dynamic_balance\",\n      \"trigger\": \"motorcycle is moving at high speed\",\n      \"actions\": [\n        {\n          \"action\": \"automatically adjust body lean for stability\"\n        },\n        {\n          \"action\": \"counterbalance centrifugal forces during turns\"\n        }\n      ]\n    },\n    {\n      \"name\": \"speed_based_lean\",\n      \"trigger\": \"motorcycle changes velocity\",\n      \"actions\": [\n        {\n          \"action\": \"increase lean angle with higher speed\"\n        },\n        {\n          \"action\": \"reduce lean angle when slowing down\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class MotorcycleLean : MonoBehaviour\n{\n    [SerializeField] private float maxLeanAngle = 45f;\n    [SerializeField] private float leanSpeed = 5f;\n    [SerializeField] private float steeringInput;\n\n    [Header(\"References\")]\n    [SerializeField] private Rigidbody motorcycleRigidbody;\n    [SerializeField] private Transform motorcycleModel;\n\n    private void Start()\n    {\n        // Ensure rigidbody is assigned\n        if (motorcycleRigidbody == null)\n            motorcycleRigidbody = GetComponent<Rigidbody>();\n    }\n\n    private void Update()\n    {\n        // Get horizontal input for steering\n        steeringInput = Input.GetAxis(\"Horizontal\");\n    }\n\n    private void FixedUpdate()\n    {\n        ApplyLeanRotation();\n    }\n\n    private void ApplyLeanRotation()\n    {\n        // Calculate lean angle based on steering input\n        float targetLeanAngle = steeringInput * maxLeanAngle;\n        \n        // Smoothly interpolate current lean to target lean\n        Vector3 currentLean = motorcycleModel.localRotation.eulerAngles;\n        Vector3 targetLean = new Vector3(0, currentLean.y, -targetLeanAngle);\n\n        motorcycleModel.localRotation = Quaternion.Slerp(\n            motorcycleModel.localRotation, \n            Quaternion.Euler(targetLean), \n            leanSpeed * Time.fixedDeltaTime\n        );\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HealthBar\",\n  \"components\": [\n    \"UI Image\",\n    \"Slider\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"currentHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    },\n    {\n      \"name\": \"maxHealth\",\n      \"type\": \"float\",\n      \"default\": 100\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"update_health_display\",\n      \"trigger\": \"player takes damage or healing\",\n      \"actions\": [\n        {\n          \"action\": \"adjust slider value to match current health percentage\"\n        },\n        {\n          \"action\": \"change health bar color based on current health level\"\n        },\n        {\n          \"action\": \"show warning color when health is critically low\"\n        }\n      ]\n    },\n    {\n      \"name\": \"initialize_health_bar\",\n      \"trigger\": \"when game object starts\",\n      \"actions\": [\n        {\n          \"action\": \"set maximum health value on slider\"\n        },\n        {\n          \"action\": \"set initial health to full value\"\n        },\n        {\n          \"action\": \"configure default health bar appearance\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing UnityEngine.UI;\n\npublic class HealthBar : MonoBehaviour\n{\n    [SerializeField] private Image healthBarFill;\n    [SerializeField] private float maxHealth = 100f;\n\n    private float currentHealth;\n\n    private void Start()\n    {\n        // Initialize health to full at start\n        currentHealth = maxHealth;\n        UpdateHealthBar();\n    }\n\n    public void TakeDamage(float damageAmount)\n    {\n        // Ensure damage doesn't go below zero\n        currentHealth = Mathf.Max(currentHealth - damageAmount, 0f);\n        UpdateHealthBar();\n\n        // Optional: Check for death\n        if (currentHealth <= 0)\n        {\n            OnDeath();\n        }\n    }\n\n    public void Heal(float healAmount)\n    {\n        // Ensure healing doesn't exceed max health\n        currentHealth = Mathf.Min(currentHealth + healAmount, maxHealth);\n        UpdateHealthBar();\n    }\n\n    private void UpdateHealthBar()\n    {\n        // Validate health bar reference\n        if (healthBarFill == null)\n        {\n            Debug.LogWarning(\"Health bar fill image is not assigned!\");\n            return;\n        }\n\n        // Update fill amount based on current health percentage\n        healthBarFill.fillAmount = currentHealth / maxHealth;\n    }\n\n    private void OnDeath()\n    {\n        // Implement death logic here\n        Debug.Log(\"Entity has died!\");\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"LavaFloor\",\n  \"components\": [\n    \"Collider\",\n    \"Renderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"damageAmount\",\n      \"type\": \"float\",\n      \"default\": 10\n    },\n    {\n      \"name\": \"damageInterval\",\n      \"type\": \"float\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"detectionRadius\",\n      \"type\": \"float\",\n      \"default\": 2\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"damage_player_over_time\",\n      \"trigger\": \"when player is standing on lava surface\",\n      \"actions\": [\n        {\n          \"action\": \"start periodic damage timer\"\n        },\n        {\n          \"action\": \"reduce player health gradually\"\n        }\n      ]\n    },\n    {\n      \"name\": \"visual_heat_effect\",\n      \"trigger\": \"while player is touching lava\",\n      \"actions\": [\n        {\n          \"action\": \"apply heat distortion visual effect\"\n        },\n        {\n          \"action\": \"increase surface brightness\"\n        }\n      ]\n    },\n    {\n      \"name\": \"player_exit_lava\",\n      \"trigger\": \"when player leaves lava surface\",\n      \"actions\": [\n        {\n          \"action\": \"stop periodic damage timer\"\n        },\n        {\n          \"action\": \"reset visual heat effects\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class LavaFloor : MonoBehaviour\n{\n    [SerializeField] private float damageAmount = 10f;\n    [SerializeField] private float damageInterval = 1f;\n    [SerializeField] private LayerMask playerLayer;\n\n    private float nextDamageTime;\n\n    private void OnTriggerStay2D(Collider2D other)\n    {\n        // Check if the object is on the player layer\n        if (((1 << other.gameObject.layer) & playerLayer) != 0)\n        {\n            // Check if it's time to apply damage\n            if (Time.time >= nextDamageTime)\n            {\n                // Get the health component\n                Health playerHealth = other.GetComponent<Health>();\n                \n                if (playerHealth != null)\n                {\n                    // Apply damage to the player\n                    playerHealth.TakeDamage(damageAmount);\n                    \n                    // Set next damage time\n                    nextDamageTime = Time.time + damageInterval;\n                }\n            }\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"MovingPlatform\",\n  \"components\": [\n    \"Transform\",\n    \"Rigidbody\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"startPosition\",\n      \"type\": \"Vector3\",\n      \"default\": null\n    },\n    {\n      \"name\": \"endPosition\",\n      \"type\": \"Vector3\",\n      \"default\": null\n    },\n    {\n      \"name\": \"movementSpeed\",\n      \"type\": \"float\",\n      \"default\": 2.5\n    },\n    {\n      \"name\": \"pauseDuration\",\n      \"type\": \"float\",\n      \"default\": 1.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"platform_movement\",\n      \"trigger\": \"platform starts or reaches destination point\",\n      \"actions\": [\n        {\n          \"action\": \"smoothly move between start and end points\"\n        },\n        {\n          \"action\": \"pause briefly at each destination\"\n        },\n        {\n          \"action\": \"reverse movement direction when reaching endpoint\"\n        }\n      ]\n    },\n    {\n      \"name\": \"player_interaction\",\n      \"trigger\": \"player stands on platform\",\n      \"actions\": [\n        {\n          \"action\": \"carry player along with platform's movement\"\n        },\n        {\n          \"action\": \"maintain player's relative position\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class MovingPlatform : MonoBehaviour\n{\n    [SerializeField] private Transform pointA;\n    [SerializeField] private Transform pointB;\n    [SerializeField] private float moveSpeed = 2f;\n    [SerializeField] private float waitTime = 1f;\n\n    private Vector3 targetPosition;\n    private float waitCounter;\n    private bool movingToB = true;\n\n    private void Start()\n    {\n        // Validate points are assigned\n        if (pointA == null || pointB == null)\n        {\n            Debug.LogError(\"Platform points not assigned!\");\n            enabled = false;\n            return;\n        }\n\n        // Initial position setup\n        transform.position = pointA.position;\n        targetPosition = pointB.position;\n    }\n\n    private void Update()\n    {\n        // Wait at each point before changing direction\n        if (Vector3.Distance(transform.position, targetPosition) < 0.1f)\n        {\n            waitCounter += Time.deltaTime;\n\n            if (waitCounter >= waitTime)\n            {\n                // Switch target point\n                movingToB = !movingToB;\n                targetPosition = movingToB ? pointB.position : pointA.position;\n                waitCounter = 0;\n            }\n            return;\n        }\n\n        // Move platform smoothly\n        transform.position = Vector3.MoveTowards(\n            transform.position, \n            targetPosition, \n            moveSpeed * Time.deltaTime\n        );\n    }\n\n    // Optional: Visualize points in editor\n    private void OnDrawGizmosSelected()\n    {\n        if (pointA != null && pointB != null)\n        {\n            Gizmos.color = Color.green;\n            Gizmos.DrawLine(pointA.position, pointB.position);\n            Gizmos.DrawSphere(pointA.position, 0.2f);\n            Gizmos.DrawSphere(pointB.position, 0.2f);\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"HackableTerminal\",\n  \"components\": [\n    \"Interactable\",\n    \"AudioSource\",\n    \"MeshRenderer\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"hackDifficulty\",\n      \"type\": \"int\",\n      \"default\": 3\n    },\n    {\n      \"name\": \"isHacked\",\n      \"type\": \"bool\",\n      \"default\": false\n    },\n    {\n      \"name\": \"hackProgress\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"requiredHackTime\",\n      \"type\": \"float\",\n      \"default\": 5.0\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"detect_player_interaction\",\n      \"trigger\": \"when player approaches terminal within interaction range\",\n      \"actions\": [\n        {\n          \"action\": \"display interaction prompt\"\n        },\n        {\n          \"action\": \"highlight terminal interface\"\n        }\n      ]\n    },\n    {\n      \"name\": \"initiate_hacking\",\n      \"trigger\": \"when player starts hacking terminal\",\n      \"actions\": [\n        {\n          \"action\": \"start hacking minigame\"\n        },\n        {\n          \"action\": \"play hacking startup sound\"\n        },\n        {\n          \"action\": \"disable normal terminal interface\"\n        }\n      ]\n    },\n    {\n      \"name\": \"process_hack_attempt\",\n      \"trigger\": \"during active hacking attempt\",\n      \"actions\": [\n        {\n          \"action\": \"increase hack progress based on player skill\"\n        },\n        {\n          \"action\": \"generate random hacking challenges\"\n        },\n        {\n          \"action\": \"show hack progress meter\"\n        }\n      ]\n    },\n    {\n      \"name\": \"complete_hack\",\n      \"trigger\": \"when hack progress reaches required threshold\",\n      \"actions\": [\n        {\n          \"action\": \"mark terminal as successfully hacked\"\n        },\n        {\n          \"action\": \"unlock terminal's secured data\"\n        },\n        {\n          \"action\": \"play successful hacking sound\"\n        },\n        {\n          \"action\": \"grant player access to terminal functions\"\n        }\n      ]\n    },\n    {\n      \"name\": \"hack_failure\",\n      \"trigger\": \"when hacking attempt fails or is interrupted\",\n      \"actions\": [\n        {\n          \"action\": \"trigger security lockout\"\n        },\n        {\n          \"action\": \"play alarm sound\"\n        },\n        {\n          \"action\": \"reset hack progress\"\n        },\n        {\n          \"action\": \"temporarily disable terminal interaction\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\nusing System.Collections.Generic;\nusing UnityEngine.UI;\n\npublic class HackableTerminal : MonoBehaviour\n{\n    [Header(\"Terminal Configuration\")]\n    [SerializeField] private Text outputText;\n    [SerializeField] private InputField commandInput;\n    [SerializeField] private Button submitButton;\n\n    [Header(\"Hack Settings\")]\n    [SerializeField] private float hackDifficulty = 0.5f;\n    [SerializeField] private int requiredHackSkill = 3;\n\n    [Header(\"Security Levels\")]\n    [SerializeField] private List<string> securityCodes;\n\n    private bool isHacked = false;\n    private int hackAttempts = 0;\n    private const int MAX_HACK_ATTEMPTS = 5;\n\n    private void Start()\n    {\n        // Initialize terminal components\n        if (submitButton != null)\n            submitButton.onClick.AddListener(ProcessCommand);\n\n        // Default terminal state\n        outputText.text = \"SYSTEM TERMINAL ONLINE\\n> \";\n    }\n\n    private void ProcessCommand()\n    {\n        if (commandInput == null) return;\n\n        string command = commandInput.text.Trim().ToUpper();\n\n        if (!isHacked)\n        {\n            AttemptHack(command);\n        }\n        else\n        {\n            ExecuteHackedCommand(command);\n        }\n\n        // Clear input field\n        commandInput.text = string.Empty;\n    }\n\n    private void AttemptHack(string inputCode)\n    {\n        hackAttempts++;\n\n        if (securityCodes.Contains(inputCode))\n        {\n            CompleteHack();\n        }\n        else if (hackAttempts >= MAX_HACK_ATTEMPTS)\n        {\n            TriggerSecurityLockout();\n        }\n        else\n        {\n            outputText.text += $\"\\nHACK ATTEMPT FAILED ({hackAttempts}/{MAX_HACK_ATTEMPTS})\\n> \";\n        }\n    }\n\n    private void CompleteHack()\n    {\n        isHacked = true;\n        outputText.text += \"\\n[SYSTEM COMPROMISED]\\nRoot Access Granted.\\n> \";\n    }\n\n    private void TriggerSecurityLockout()\n    {\n        outputText.text += \"\\n[SECURITY LOCKOUT ACTIVATED]\\nSystem Blocked.\\n\";\n        submitButton.interactable = false;\n    }\n\n    private void ExecuteHackedCommand(string command)\n    {\n        switch (command)\n        {\n            case \"HELP\":\n                outputText.text += \"\\nAvailable Commands:\\n- SYSTEM_INFO\\n- NETWORK_MAP\\n- SHUTDOWN\\n> \";\n                break;\n            case \"SYSTEM_INFO\":\n                outputText.text += \"\\nSYSTEM DIAGNOSTICS:\\nStatus: Compromised\\nAccess Level: Root\\n> \";\n                break;\n            case \"NETWORK_MAP\":\n                outputText.text += \"\\nNETWORK TOPOLOGY:\\n[CLASSIFIED DATA]\\n> \";\n                break;\n            case \"SHUTDOWN\":\n                outputText.text += \"\\nInitiating System Shutdown...\\n\";\n                break;\n            default:\n                outputText.text += $\"\\nUnknown Command: {command}\\n> \";\n                break;\n        }\n    }\n}"}]}
{"conversations": [{"from": "system", "value": "You are a Unity C# code generator. Convert the behavior specification into a complete MonoBehaviour script.\n\nREQUIREMENTS:\n1. Use proper Unity lifecycle methods (Start, Update, FixedUpdate, OnTriggerEnter, OnCollisionEnter, etc.)\n2. Use correct Unity APIs - never invent methods that don't exist\n3. Declare all configurable fields as public or [SerializeField] private\n4. Add required using statements (UnityEngine, System.Collections, etc.)\n5. Make the code production-ready and compilable\n6. Match the behavior specification exactly - implement all described behaviors\n7. Use GetComponent<T>() in Start() or Awake() for component references\n8. Handle null checks appropriately\n\nCOMMON UNITY PATTERNS:\n- Play audio: audioSource.Play() or AudioSource.PlayClipAtPoint(clip, position)\n- Apply force: rigidbody.AddForce(direction * force)\n- Detect collision: OnCollisionEnter(Collision collision) or OnTriggerEnter(Collider other)\n- Spawn object: Instantiate(prefab, position, rotation)\n- Destroy: Destroy(gameObject) or Destroy(gameObject, delay)\n- Check tag: other.CompareTag(\"TagName\")\n- Move: transform.Translate() or rigidbody.MovePosition()\n- Rotate: transform.Rotate() or Quaternion.Euler()\n\nOutput ONLY the C# code. No markdown, no explanations, no comments about what you're doing."}, {"from": "human", "value": "BEHAVIOR SPECIFICATION:\n{\n  \"class_name\": \"PuzzleRing\",\n  \"components\": [\n    \"Rigidbody\",\n    \"AudioSource\"\n  ],\n  \"fields\": [\n    {\n      \"name\": \"rotationSpeed\",\n      \"type\": \"float\",\n      \"default\": 30\n    },\n    {\n      \"name\": \"currentRotationDirection\",\n      \"type\": \"int\",\n      \"default\": 1\n    },\n    {\n      \"name\": \"correctAlignmentAngle\",\n      \"type\": \"float\",\n      \"default\": 0\n    },\n    {\n      \"name\": \"rotationSnapThreshold\",\n      \"type\": \"float\",\n      \"default\": 5\n    }\n  ],\n  \"behaviors\": [\n    {\n      \"name\": \"rotate_ring\",\n      \"trigger\": \"player clicks on puzzle ring\",\n      \"actions\": [\n        {\n          \"action\": \"change rotation direction\"\n        },\n        {\n          \"action\": \"rotate ring around central axis\"\n        },\n        {\n          \"action\": \"play rotation sound effect\"\n        }\n      ]\n    },\n    {\n      \"name\": \"check_puzzle_solution\",\n      \"trigger\": \"ring stops rotating\",\n      \"actions\": [\n        {\n          \"action\": \"check if ring is aligned with correct angle\"\n        },\n        {\n          \"action\": \"if aligned perfectly, trigger puzzle completion\"\n        },\n        {\n          \"action\": \"if not aligned, reset ring position\"\n        }\n      ]\n    },\n    {\n      \"name\": \"reset_puzzle\",\n      \"trigger\": \"puzzle solution is incorrect after multiple attempts\",\n      \"actions\": [\n        {\n          \"action\": \"reset ring to initial rotation\"\n        },\n        {\n          \"action\": \"play reset sound effect\"\n        }\n      ]\n    }\n  ]\n}\n\nGenerate the complete Unity C# MonoBehaviour script:"}, {"from": "gpt", "value": "using UnityEngine;\n\npublic class PuzzleRingRotator : MonoBehaviour\n{\n    [SerializeField] private float rotationSpeed = 50f;\n    [SerializeField] private bool isRotating = true;\n    [SerializeField] private RotationAxis rotationAxis = RotationAxis.Y;\n\n    private enum RotationAxis\n    {\n        X,\n        Y,\n        Z\n    }\n\n    private void Update()\n    {\n        if (!isRotating) return;\n\n        Vector3 axisToRotate = GetRotationAxis();\n        transform.Rotate(axisToRotate * rotationSpeed * Time.deltaTime);\n    }\n\n    private Vector3 GetRotationAxis()\n    {\n        return rotationAxis switch\n        {\n            RotationAxis.X => Vector3.right,\n            RotationAxis.Y => Vector3.up,\n            RotationAxis.Z => Vector3.forward,\n            _ => Vector3.up\n        };\n    }\n\n    public void ToggleRotation()\n    {\n        isRotating = !isRotating;\n    }\n\n    public void SetRotationSpeed(float speed)\n    {\n        rotationSpeed = Mathf.Abs(speed);\n    }\n\n    public void SetRotationAxis(RotationAxis axis)\n    {\n        rotationAxis = axis;\n    }\n}"}]}
